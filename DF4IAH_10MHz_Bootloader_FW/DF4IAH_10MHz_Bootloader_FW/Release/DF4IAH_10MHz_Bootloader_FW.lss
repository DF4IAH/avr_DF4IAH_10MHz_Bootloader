
DF4IAH_10MHz_Bootloader_FW.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000002  00800100  00007726  0000083a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .df4iah_bl_clkpullpwm 0000004e  00007780  00007780  0000083c  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .df4iah_bl_probe 00000036  000078c0  000078c0  0000088a  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .df4iah_bl_memory 000002c4  00007900  00007900  000008c0  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .df4iah_bl_usb 000003ee  00007be0  00007be0  00000b84  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  5 .text         00000726  00007000  00007000  00000114  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  6 .bss          0000005e  00800102  00800102  00000f72  2**0
                  ALLOC
  7 .comment      00000030  00000000  00000000  00000f72  2**0
                  CONTENTS, READONLY
  8 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000fa4  2**2
                  CONTENTS, READONLY
  9 .debug_aranges 000001a0  00000000  00000000  00000fe8  2**3
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_info   0000215a  00000000  00000000  00001188  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 00001058  00000000  00000000  000032e2  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   000018f0  00000000  00000000  0000433a  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_frame  000002c0  00000000  00000000  00005c2c  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    00000a88  00000000  00000000  00005eec  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_loc    0000145b  00000000  00000000  00006974  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_ranges 00000160  00000000  00000000  00007dcf  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .df4iah_bl_clkpullpwm:

00007780 <clkPullPwm_bl_init>:
__attribute__((section(".df4iah_bl_clkpullpwm"), aligned(2)))
#endif
void clkPullPwm_bl_init()
{
	// power up this module
	PRR &= ~(_BV(PRTIM0));
    7780:	e4 e6       	ldi	r30, 0x64	; 100
    7782:	f0 e0       	ldi	r31, 0x00	; 0
    7784:	80 81       	ld	r24, Z
    7786:	8f 7d       	andi	r24, 0xDF	; 223
    7788:	80 83       	st	Z, r24

	// set the timer-0 counter to zero.
	TCNT0 = 0x00;
    778a:	16 bc       	out	0x26, r1	; 38

	// set the timer-0 PWM-B compare register
	OCR0B = DEFAULT_PWM_COUNT;
    778c:	88 e7       	ldi	r24, 0x78	; 120
    778e:	88 bd       	out	0x28, r24	; 40

	// set the timer-0 mode of operation: 0x3 = Fast PWM, counting up, TOP := MAX [. . WGM01 WGM00]
	// set the timer-0 compare-B waveform generator to: PWM, 1 at >= match, 0 else
	TCCR0A = (0b10<<COM0B0) | (0b11<<WGM00);
    7790:	83 e2       	ldi	r24, 0x23	; 35
    7792:	84 bd       	out	0x24, r24	; 36

	// set the timer-0 mode of operation: 0x3 = Fast PWM, counting up, TOP := MAX [WGM02 . .]
	// set the timer-0 clock source to 20 MHz XTAL.
	TCCR0B = (0b0<<WGM02) | (0b001<<CS00);
    7794:	81 e0       	ldi	r24, 0x01	; 1
    7796:	85 bd       	out	0x25, r24	; 37

	// set the timer-0 PWM-B compare output: setting data port for output
	DDR_OC0B_REG |= _BV(DDR_OC0B);
    7798:	55 9a       	sbi	0x0a, 5	; 10


	// set the DEBUG port to output
	PWMTOGGLEPIN_PORT |= _BV(PWMTOGGLEPIN_PNUM);
    779a:	45 9a       	sbi	0x08, 5	; 8
	PWMTOGGLEPIN_DDR  |= _BV(PWMTOGGLEPIN_PNUM);
    779c:	3d 9a       	sbi	0x07, 5	; 7
    779e:	08 95       	ret

000077a0 <clkPullPwm_bl_close>:
__attribute__((section(".df4iah_bl_clkpullpwm"), aligned(2)))
#endif
void clkPullPwm_bl_close()
{
	// reset the DEBUG port
	PWMTOGGLEPIN_DDR &= ~(_BV(PWMTOGGLEPIN_PNUM));
    77a0:	3d 98       	cbi	0x07, 5	; 7


	// reset timer-0 PWM-B compare output port
	DDR_OC0B_REG &= ~(_BV(DDR_OC0B));
    77a2:	55 98       	cbi	0x0a, 5	; 10

	// stop timer-0
	TCCR0B = (0b00<<WGM02)  | (0b000<<CS00);
    77a4:	15 bc       	out	0x25, r1	; 37

	// stop timer-0 compare output
	TCCR0A = (0b00<<COM0B0) | (0b00<<WGM00);
    77a6:	14 bc       	out	0x24, r1	; 36

	// set the timer-0 compare-B value to zero.
	OCR0B = 0x00;
    77a8:	18 bc       	out	0x28, r1	; 40

	// set the timer-0 counter to zero.
	TCNT0 = 0x00;
    77aa:	16 bc       	out	0x26, r1	; 38

	// no more power is needed for this module
	PRR |= _BV(PRTIM0);
    77ac:	e4 e6       	ldi	r30, 0x64	; 100
    77ae:	f0 e0       	ldi	r31, 0x00	; 0
    77b0:	80 81       	ld	r24, Z
    77b2:	80 62       	ori	r24, 0x20	; 32
    77b4:	80 83       	st	Z, r24
    77b6:	08 95       	ret

000077b8 <clkPullPwm_bl_togglePin>:
#ifdef RELEASE
__attribute__((section(".df4iah_bl_clkpullpwm"), aligned(2)))
#endif
inline void clkPullPwm_bl_togglePin()
{
	PWMTOGGLEPIN_PIN = _BV(PWMTOGGLEPIN_PNUM);
    77b8:	80 e2       	ldi	r24, 0x20	; 32
    77ba:	86 b9       	out	0x06, r24	; 6
    77bc:	08 95       	ret

000077be <clkPullPwm_bl_endlessTogglePin>:
    77be:	80 e2       	ldi	r24, 0x20	; 32
    77c0:	86 b9       	out	0x06, r24	; 6
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    77c2:	96 e0       	ldi	r25, 0x06	; 6
    77c4:	9a 95       	dec	r25
    77c6:	f1 f7       	brne	.-4      	; 0x77c4 <clkPullPwm_bl_endlessTogglePin+0x6>
    77c8:	00 c0       	rjmp	.+0      	; 0x77ca <clkPullPwm_bl_endlessTogglePin+0xc>
void clkPullPwm_bl_endlessTogglePin()
{
	for(;;)	{
		clkPullPwm_bl_togglePin();
		_delay_ms(1);
		wdt_reset();
    77ca:	a8 95       	wdr
	}
    77cc:	f9 cf       	rjmp	.-14     	; 0x77c0 <clkPullPwm_bl_endlessTogglePin+0x2>

Disassembly of section .df4iah_bl_probe:

000078c0 <probe_bl_close>:
#ifdef RELEASE
__attribute__((section(".df4iah_bl_probe"), aligned(2)))
#endif
void probe_bl_close()
{
	PROBE_PORT &= ~(_BV(PROBE_PNUM));				// clear PULLUP to default
    78c0:	5b 98       	cbi	0x0b, 3	; 11
    78c2:	08 95       	ret

000078c4 <probe_bl_checkJumper>:
#ifdef RELEASE
__attribute__((section(".df4iah_bl_probe"), aligned(2)))
#endif
inline uint8_t probe_bl_checkJumper()
{
	if (PROBE_PIN & _BV(PROBE_PNUM)) {
    78c4:	89 b1       	in	r24, 0x09	; 9
    78c6:	83 fb       	bst	r24, 3
    78c8:	88 27       	eor	r24, r24
    78ca:	80 f9       	bld	r24, 0
		// pin is not grounded - JUMPER open
		return 0;
	}
	return 1;  // JUMPER closed
}
    78cc:	91 e0       	ldi	r25, 0x01	; 1
    78ce:	89 27       	eor	r24, r25
    78d0:	08 95       	ret

000078d2 <probe_bl_init>:
#ifdef RELEASE
__attribute__((section(".df4iah_bl_probe"), aligned(2)))
#endif
void probe_bl_init()
{
	MCUCR &= ~(_BV(PUD));							// PullUp Disable off
    78d2:	85 b7       	in	r24, 0x35	; 53
    78d4:	8f 7e       	andi	r24, 0xEF	; 239
    78d6:	85 bf       	out	0x35, r24	; 53

	PROBE_DDR  &= ~(_BV(PROBE_PNUM));				// set probe line as input
    78d8:	53 98       	cbi	0x0a, 3	; 10
	PROBE_PORT |=   _BV(PROBE_PNUM);				// and enable the PullUp
    78da:	5b 9a       	sbi	0x0b, 3	; 11

	uint8_t dlyCnt = 10;
	while (--dlyCnt) {								// delay for a reliable detection
    78dc:	8a e0       	ldi	r24, 0x0A	; 10
    78de:	81 50       	subi	r24, 0x01	; 1
    78e0:	31 f0       	breq	.+12     	; 0x78ee <probe_bl_init+0x1c>
        wdt_reset();
    78e2:	a8 95       	wdr
    78e4:	96 e0       	ldi	r25, 0x06	; 6
    78e6:	9a 95       	dec	r25
    78e8:	f1 f7       	brne	.-4      	; 0x78e6 <probe_bl_init+0x14>
    78ea:	00 c0       	rjmp	.+0      	; 0x78ec <probe_bl_init+0x1a>
    78ec:	f8 cf       	rjmp	.-16     	; 0x78de <probe_bl_init+0xc>
        _delay_ms(1);
    }
	mainIsJumperBlSet = probe_bl_checkJumper();
    78ee:	ea df       	rcall	.-44     	; 0x78c4 <probe_bl_checkJumper>
    78f0:	80 93 03 01 	sts	0x0103, r24	; 0x800103 <mainIsJumperBlSet>
    78f4:	08 95       	ret

Disassembly of section .df4iah_bl_memory:

00007900 <memory_bl_eraseFlash>:

#ifdef RELEASE
__attribute__((section(".df4iah_bl_memory"), aligned(2)))
#endif
void memory_bl_eraseFlash(void)
{
    7900:	e0 e0       	ldi	r30, 0x00	; 0
    7902:	f0 e0       	ldi	r31, 0x00	; 0
	const uint32_t C_app_end = APP_END;
	uint32_t addr = 0;

	// erase only main section (bootloader protection)
	while (C_app_end >= addr) {
		boot_page_erase(addr);								// perform page erase
    7904:	83 e0       	ldi	r24, 0x03	; 3
    7906:	80 93 57 00 	sts	0x0057, r24	; 0x800057 <__TEXT_REGION_LENGTH__+0x7e0057>
    790a:	e8 95       	spm
		boot_spm_busy_wait();								// wait until the memory is erased.
    790c:	07 b6       	in	r0, 0x37	; 55
    790e:	00 fc       	sbrc	r0, 0
    7910:	fd cf       	rjmp	.-6      	; 0x790c <memory_bl_eraseFlash+0xc>
    7912:	e0 58       	subi	r30, 0x80	; 128
    7914:	ff 4f       	sbci	r31, 0xFF	; 255
{
	const uint32_t C_app_end = APP_END;
	uint32_t addr = 0;

	// erase only main section (bootloader protection)
	while (C_app_end >= addr) {
    7916:	e1 15       	cp	r30, r1
    7918:	90 e7       	ldi	r25, 0x70	; 112
    791a:	f9 07       	cpc	r31, r25
    791c:	a1 f7       	brne	.-24     	; 0x7906 <memory_bl_eraseFlash+0x6>
		boot_page_erase(addr);								// perform page erase
		boot_spm_busy_wait();								// wait until the memory is erased.
		addr += SPM_PAGESIZE;
	}
	boot_rww_enable();
    791e:	81 e1       	ldi	r24, 0x11	; 17
    7920:	80 93 57 00 	sts	0x0057, r24	; 0x800057 <__TEXT_REGION_LENGTH__+0x7e0057>
    7924:	e8 95       	spm
    7926:	08 95       	ret

00007928 <memory_bl_readFlashPage>:

#ifdef RELEASE
__attribute__((section(".df4iah_bl_memory"), aligned(2)))
#endif
void memory_bl_readFlashPage(uint8_t target[], pagebuf_t size, uint32_t baddr)
{
    7928:	ff 92       	push	r15
    792a:	0f 93       	push	r16
    792c:	1f 93       	push	r17
    792e:	cf 93       	push	r28
    7930:	df 93       	push	r29
    7932:	dc 01       	movw	r26, r24
    7934:	92 2f       	mov	r25, r18
	const uint32_t C_app_end = APP_END;
	uint16_t data;
	uint8_t idx = 0;

	while (size) {
    7936:	02 2f       	mov	r16, r18
    7938:	13 2f       	mov	r17, r19
    793a:	9a 01       	movw	r18, r20
    793c:	51 e0       	ldi	r21, 0x01	; 1
    793e:	59 1b       	sub	r21, r25
    7940:	40 2f       	mov	r20, r16
    7942:	f0 2e       	mov	r15, r16
    7944:	f9 1a       	sub	r15, r25
    7946:	66 23       	and	r22, r22
    7948:	f9 f0       	breq	.+62     	; 0x7988 <memory_bl_readFlashPage+0x60>
#ifndef READ_PROTECT_BOOTLOADER
# warning "Bootloader not read-protected"
		if (true) {
#else
		// don't read bootloader
		if (baddr < C_app_end) {
    794a:	0f 3f       	cpi	r16, 0xFF	; 255
    794c:	8f e6       	ldi	r24, 0x6F	; 111
    794e:	18 07       	cpc	r17, r24
    7950:	21 05       	cpc	r18, r1
    7952:	31 05       	cpc	r19, r1
    7954:	30 f4       	brcc	.+12     	; 0x7962 <memory_bl_readFlashPage+0x3a>
#if defined(RAMPZ)
			data = pgm_read_word_far(baddr);
#else
			data = pgm_read_word_near(baddr);
    7956:	f8 01       	movw	r30, r16
    7958:	c5 91       	lpm	r28, Z+
    795a:	d4 91       	lpm	r29, Z
    795c:	7c 2f       	mov	r23, r28
    795e:	8d 2f       	mov	r24, r29
    7960:	02 c0       	rjmp	.+4      	; 0x7966 <memory_bl_readFlashPage+0x3e>
#endif
		}
		else {
			data = 0xFFFF; 									// fake empty, no access to the bootloader
    7962:	7f ef       	ldi	r23, 0xFF	; 255
    7964:	8f ef       	ldi	r24, 0xFF	; 255
		}
#endif
		target[idx++] = data & 0xff;						// store LSB
    7966:	fd 01       	movw	r30, r26
    7968:	ef 0d       	add	r30, r15
    796a:	f1 1d       	adc	r31, r1
    796c:	70 83       	st	Z, r23
		if (--size) {
    796e:	61 30       	cpi	r22, 0x01	; 1
    7970:	59 f0       	breq	.+22     	; 0x7988 <memory_bl_readFlashPage+0x60>
    7972:	45 0f       	add	r20, r21
			target[idx++] = data >> 8;						// store MSB
    7974:	fd 01       	movw	r30, r26
    7976:	e4 0f       	add	r30, r20
    7978:	f1 1d       	adc	r31, r1
    797a:	80 83       	st	Z, r24
			baddr += 2;										// select next word in memory
    797c:	0e 5f       	subi	r16, 0xFE	; 254
    797e:	1f 4f       	sbci	r17, 0xFF	; 255
    7980:	2f 4f       	sbci	r18, 0xFF	; 255
    7982:	3f 4f       	sbci	r19, 0xFF	; 255
			--size;											// subtract two bytes from number of bytes to read
    7984:	62 50       	subi	r22, 0x02	; 2
    7986:	dc cf       	rjmp	.-72     	; 0x7940 <memory_bl_readFlashPage+0x18>
		}
	}														// repeat until block has been read
}
    7988:	df 91       	pop	r29
    798a:	cf 91       	pop	r28
    798c:	1f 91       	pop	r17
    798e:	0f 91       	pop	r16
    7990:	ff 90       	pop	r15
    7992:	08 95       	ret

00007994 <memory_bl_readEEpromPage>:

#ifdef RELEASE
__attribute__((section(".df4iah_bl_memory"), aligned(2)))
#endif
void memory_bl_readEEpromPage(uint8_t target[], pagebuf_t size, uint16_t baddr)
{
    7994:	ef 92       	push	r14
    7996:	ff 92       	push	r15
    7998:	0f 93       	push	r16
    799a:	1f 93       	push	r17
    799c:	cf 93       	push	r28
    799e:	df 93       	push	r29
    79a0:	1f 92       	push	r1
    79a2:	cd b7       	in	r28, 0x3d	; 61
    79a4:	de b7       	in	r29, 0x3e	; 62
	uint8_t idx = 0;

	while (size) {
    79a6:	7c 01       	movw	r14, r24
    79a8:	8a 01       	movw	r16, r20
    79aa:	08 1b       	sub	r16, r24
    79ac:	19 0b       	sbc	r17, r25
    79ae:	66 23       	and	r22, r22
    79b0:	59 f0       	breq	.+22     	; 0x79c8 <memory_bl_readEEpromPage+0x34>
		target[idx++] = eeprom_read_byte((uint8_t*) baddr++);
    79b2:	c8 01       	movw	r24, r16
    79b4:	8e 0d       	add	r24, r14
    79b6:	9f 1d       	adc	r25, r15
    79b8:	69 83       	std	Y+1, r22	; 0x01
    79ba:	9d de       	rcall	.-710    	; 0x76f6 <eeprom_read_byte>
    79bc:	f7 01       	movw	r30, r14
    79be:	81 93       	st	Z+, r24
    79c0:	7f 01       	movw	r14, r30
		--size;												// decrease number of bytes to read, repeat until block has been read
    79c2:	69 81       	ldd	r22, Y+1	; 0x01
    79c4:	61 50       	subi	r22, 0x01	; 1
    79c6:	f3 cf       	rjmp	.-26     	; 0x79ae <memory_bl_readEEpromPage+0x1a>
	}
}
    79c8:	0f 90       	pop	r0
    79ca:	df 91       	pop	r29
    79cc:	cf 91       	pop	r28
    79ce:	1f 91       	pop	r17
    79d0:	0f 91       	pop	r16
    79d2:	ff 90       	pop	r15
    79d4:	ef 90       	pop	r14

#ifdef RELEASE
__attribute__((section(".df4iah_bl_memory"), aligned(2)))
#endif
void memory_bl_writeFlashPage(uint8_t source[], pagebuf_t size, uint32_t baddr)
{
    79d6:	08 95       	ret

000079d8 <memory_bl_writeFlashPage>:
    79d8:	2f 92       	push	r2
    79da:	3f 92       	push	r3
    79dc:	4f 92       	push	r4
    79de:	5f 92       	push	r5
    79e0:	6f 92       	push	r6
    79e2:	7f 92       	push	r7
    79e4:	8f 92       	push	r8
    79e6:	9f 92       	push	r9
    79e8:	af 92       	push	r10
    79ea:	bf 92       	push	r11
    79ec:	cf 92       	push	r12
    79ee:	df 92       	push	r13
    79f0:	ef 92       	push	r14
    79f2:	ff 92       	push	r15
    79f4:	0f 93       	push	r16
    79f6:	1f 93       	push	r17
    79f8:	cf 93       	push	r28
    79fa:	df 93       	push	r29
    79fc:	cd b7       	in	r28, 0x3d	; 61
    79fe:	de b7       	in	r29, 0x3e	; 62
    7a00:	27 97       	sbiw	r28, 0x07	; 7
    7a02:	0f b6       	in	r0, 0x3f	; 63
    7a04:	f8 94       	cli
    7a06:	de bf       	out	0x3e, r29	; 62
    7a08:	0f be       	out	0x3f, r0	; 63
    7a0a:	cd bf       	out	0x3d, r28	; 61
	pagebuf_t sourceIdx = 0;
    7a0c:	1c 01       	movw	r2, r24

	while (size) {
    7a0e:	00 e0       	ldi	r16, 0x00	; 0
    7a10:	66 23       	and	r22, r22
    7a12:	09 f4       	brne	.+2      	; 0x7a16 <memory_bl_writeFlashPage+0x3e>
		/* calculate */
		const uint32_t C_app_end = APP_END;
		const uint8_t  pageoffs  = baddr % SPM_PAGESIZE;
    7a14:	a5 c0       	rjmp	.+330    	; 0x7b60 <memory_bl_writeFlashPage+0x188>
    7a16:	f2 2f       	mov	r31, r18
		const uint32_t pagestart = baddr - pageoffs;
    7a18:	ff 77       	andi	r31, 0x7F	; 127
    7a1a:	da 01       	movw	r26, r20
    7a1c:	c9 01       	movw	r24, r18
    7a1e:	8f 1b       	sub	r24, r31
    7a20:	91 09       	sbc	r25, r1
    7a22:	a1 09       	sbc	r26, r1
    7a24:	b1 09       	sbc	r27, r1
    7a26:	89 83       	std	Y+1, r24	; 0x01
    7a28:	9a 83       	std	Y+2, r25	; 0x02
    7a2a:	ab 83       	std	Y+3, r26	; 0x03
		const uint8_t  len       = min(SPM_PAGESIZE - pageoffs, min(size, C_app_end - baddr));
    7a2c:	bc 83       	std	Y+4, r27	; 0x04
    7a2e:	8f ef       	ldi	r24, 0xFF	; 255
    7a30:	9f e6       	ldi	r25, 0x6F	; 111
    7a32:	a0 e0       	ldi	r26, 0x00	; 0
    7a34:	b0 e0       	ldi	r27, 0x00	; 0
    7a36:	82 1b       	sub	r24, r18
    7a38:	93 0b       	sbc	r25, r19
    7a3a:	a4 0b       	sbc	r26, r20
    7a3c:	b5 0b       	sbc	r27, r21
    7a3e:	c6 2e       	mov	r12, r22
    7a40:	d1 2c       	mov	r13, r1
    7a42:	e1 2c       	mov	r14, r1
    7a44:	f1 2c       	mov	r15, r1
    7a46:	8c 15       	cp	r24, r12
    7a48:	9d 05       	cpc	r25, r13
    7a4a:	ae 05       	cpc	r26, r14
    7a4c:	bf 05       	cpc	r27, r15
    7a4e:	10 f4       	brcc	.+4      	; 0x7a54 <memory_bl_writeFlashPage+0x7c>
    7a50:	6c 01       	movw	r12, r24
    7a52:	7d 01       	movw	r14, r26
    7a54:	80 e8       	ldi	r24, 0x80	; 128
    7a56:	90 e0       	ldi	r25, 0x00	; 0
    7a58:	8f 1b       	sub	r24, r31
    7a5a:	91 09       	sbc	r25, r1
    7a5c:	09 2e       	mov	r0, r25
    7a5e:	00 0c       	add	r0, r0
    7a60:	aa 0b       	sbc	r26, r26
    7a62:	bb 0b       	sbc	r27, r27
    7a64:	8c 15       	cp	r24, r12
    7a66:	9d 05       	cpc	r25, r13
    7a68:	ae 05       	cpc	r26, r14
    7a6a:	bf 05       	cpc	r27, r15
    7a6c:	10 f4       	brcc	.+4      	; 0x7a72 <memory_bl_writeFlashPage+0x9a>
    7a6e:	6c 01       	movw	r12, r24
    7a70:	7d 01       	movw	r14, r26
		uint8_t  verifyCnt = 5;

		if (baddr >= C_app_end) {
    7a72:	7c 2d       	mov	r23, r12
    7a74:	2f 3f       	cpi	r18, 0xFF	; 255
    7a76:	9f e6       	ldi	r25, 0x6F	; 111
    7a78:	39 07       	cpc	r19, r25
    7a7a:	41 05       	cpc	r20, r1
    7a7c:	51 05       	cpc	r21, r1
    7a7e:	08 f0       	brcs	.+2      	; 0x7a82 <memory_bl_writeFlashPage+0xaa>
			return;											// short-cut
		}

		/* on each new page erase it first */
		if (!pageoffs) {
    7a80:	6f c0       	rjmp	.+222    	; 0x7b60 <memory_bl_writeFlashPage+0x188>
    7a82:	f1 11       	cpse	r31, r1
			boot_page_erase(pagestart);						// perform page erase
    7a84:	0a c0       	rjmp	.+20     	; 0x7a9a <memory_bl_writeFlashPage+0xc2>
    7a86:	93 e0       	ldi	r25, 0x03	; 3
    7a88:	99 2e       	mov	r9, r25
    7a8a:	e9 81       	ldd	r30, Y+1	; 0x01
    7a8c:	fa 81       	ldd	r31, Y+2	; 0x02
    7a8e:	90 92 57 00 	sts	0x0057, r9	; 0x800057 <__TEXT_REGION_LENGTH__+0x7e0057>
			boot_spm_busy_wait();
    7a92:	e8 95       	spm
    7a94:	07 b6       	in	r0, 0x37	; 55
    7a96:	00 fc       	sbrc	r0, 0
    7a98:	fd cf       	rjmp	.-6      	; 0x7a94 <memory_bl_writeFlashPage+0xbc>
    7a9a:	16 e0       	ldi	r17, 0x06	; 6
    7a9c:	31 01       	movw	r6, r2
    7a9e:	60 0e       	add	r6, r16
    7aa0:	71 1c       	adc	r7, r1
    7aa2:	52 2e       	mov	r5, r18
    7aa4:	3f 83       	std	Y+7, r19	; 0x07
    7aa6:	42 2e       	mov	r4, r18
		}

		/* after erasing - write up to 5 times the content of data that should '0'ing the bits */
		while (verifyCnt--) {
    7aa8:	11 50       	subi	r17, 0x01	; 1
    7aaa:	09 f4       	brne	.+2      	; 0x7aae <memory_bl_writeFlashPage+0xd6>
    7aac:	52 c0       	rjmp	.+164    	; 0x7b52 <memory_bl_writeFlashPage+0x17a>
    7aae:	7e 82       	std	Y+6, r7	; 0x06
    7ab0:	6d 82       	std	Y+5, r6	; 0x05
    7ab2:	a5 2d       	mov	r26, r5
    7ab4:	bf 81       	ldd	r27, Y+7	; 0x07
    7ab6:	53 01       	movw	r10, r6
    7ab8:	8f ef       	ldi	r24, 0xFF	; 255
    7aba:	9f ef       	ldi	r25, 0xFF	; 255
    7abc:	ea 2f       	mov	r30, r26
			const uint32_t C_word_mask = 0xfffffffe;
			uint16_t data = 0xffff;

			/* fill buffer with content */
			for (uint8_t idx = 0; idx < len; ++idx) {
    7abe:	e2 1b       	sub	r30, r18
    7ac0:	e7 17       	cp	r30, r23
				const uint16_t ptraddr = baddr + idx;
				data = (ptraddr & 1) ?  ((data & 0x00ff) | (((uint16_t) source[sourceIdx + idx]) << 8))
    7ac2:	c0 f4       	brcc	.+48     	; 0x7af4 <memory_bl_writeFlashPage+0x11c>
											:   (0xff00  |  ((uint16_t) source[sourceIdx + idx]));
    7ac4:	f5 01       	movw	r30, r10
    7ac6:	a0 ff       	sbrs	r26, 0
			uint16_t data = 0xffff;

			/* fill buffer with content */
			for (uint8_t idx = 0; idx < len; ++idx) {
				const uint16_t ptraddr = baddr + idx;
				data = (ptraddr & 1) ?  ((data & 0x00ff) | (((uint16_t) source[sourceIdx + idx]) << 8))
    7ac8:	0d c0       	rjmp	.+26     	; 0x7ae4 <memory_bl_writeFlashPage+0x10c>
    7aca:	90 80       	ld	r9, Z
											:   (0xff00  |  ((uint16_t) source[sourceIdx + idx]));
    7acc:	90 e0       	ldi	r25, 0x00	; 0
				if (ptraddr & 1) {
					boot_page_fill(ptraddr & C_word_mask, data);	// call asm routine
    7ace:	99 29       	or	r25, r9
    7ad0:	fd 01       	movw	r30, r26
    7ad2:	ee 7f       	andi	r30, 0xFE	; 254
    7ad4:	99 24       	eor	r9, r9
    7ad6:	93 94       	inc	r9
    7ad8:	0c 01       	movw	r0, r24
    7ada:	90 92 57 00 	sts	0x0057, r9	; 0x800057 <__TEXT_REGION_LENGTH__+0x7e0057>
    7ade:	e8 95       	spm
    7ae0:	11 24       	eor	r1, r1

			/* fill buffer with content */
			for (uint8_t idx = 0; idx < len; ++idx) {
				const uint16_t ptraddr = baddr + idx;
				data = (ptraddr & 1) ?  ((data & 0x00ff) | (((uint16_t) source[sourceIdx + idx]) << 8))
											:   (0xff00  |  ((uint16_t) source[sourceIdx + idx]));
    7ae2:	03 c0       	rjmp	.+6      	; 0x7aea <memory_bl_writeFlashPage+0x112>
    7ae4:	80 81       	ld	r24, Z
    7ae6:	90 e0       	ldi	r25, 0x00	; 0
    7ae8:	9f 6f       	ori	r25, 0xFF	; 255
    7aea:	ff ef       	ldi	r31, 0xFF	; 255
    7aec:	af 1a       	sub	r10, r31
    7aee:	bf 0a       	sbc	r11, r31
    7af0:	11 96       	adiw	r26, 0x01	; 1
					boot_page_fill(ptraddr & C_word_mask, data);	// call asm routine
				}
			}

			/* write the page */
			boot_page_write(pagestart);
    7af2:	e4 cf       	rjmp	.-56     	; 0x7abc <memory_bl_writeFlashPage+0xe4>
    7af4:	85 e0       	ldi	r24, 0x05	; 5
    7af6:	98 2e       	mov	r9, r24
    7af8:	e9 81       	ldd	r30, Y+1	; 0x01
    7afa:	fa 81       	ldd	r31, Y+2	; 0x02
    7afc:	90 92 57 00 	sts	0x0057, r9	; 0x800057 <__TEXT_REGION_LENGTH__+0x7e0057>
			boot_spm_busy_wait();
    7b00:	e8 95       	spm
    7b02:	07 b6       	in	r0, 0x37	; 55
    7b04:	00 fc       	sbrc	r0, 0
			boot_rww_enable();								// re-enable the RWW section
    7b06:	fd cf       	rjmp	.-6      	; 0x7b02 <memory_bl_writeFlashPage+0x12a>
    7b08:	81 e1       	ldi	r24, 0x11	; 17
    7b0a:	80 93 57 00 	sts	0x0057, r24	; 0x800057 <__TEXT_REGION_LENGTH__+0x7e0057>

			/* verify data, compare source data segment only */
			uint8_t isValid = 1;
			for (uint8_t idx = 0; idx < len; ++idx) {
    7b0e:	e8 95       	spm
    7b10:	49 01       	movw	r8, r18
    7b12:	5a 01       	movw	r10, r20
    7b14:	88 2d       	mov	r24, r8
    7b16:	84 19       	sub	r24, r4
    7b18:	87 17       	cp	r24, r23
				const uint8_t ptrdata = (pgm_read_word_near((baddr + idx) & 0xfffe) >> (((baddr + idx) & 1) ?  8 : 0));
    7b1a:	d8 f4       	brcc	.+54     	; 0x7b52 <memory_bl_writeFlashPage+0x17a>
    7b1c:	f4 01       	movw	r30, r8
    7b1e:	ee 7f       	andi	r30, 0xFE	; 254
    7b20:	85 91       	lpm	r24, Z+
    7b22:	94 91       	lpm	r25, Z
    7b24:	80 fe       	sbrs	r8, 0
    7b26:	02 c0       	rjmp	.+4      	; 0x7b2c <memory_bl_writeFlashPage+0x154>
    7b28:	f8 e0       	ldi	r31, 0x08	; 8
    7b2a:	01 c0       	rjmp	.+2      	; 0x7b2e <memory_bl_writeFlashPage+0x156>
				if (ptrdata != source[sourceIdx + idx]) {
    7b2c:	f0 e0       	ldi	r31, 0x00	; 0
    7b2e:	ad 81       	ldd	r26, Y+5	; 0x05
    7b30:	be 81       	ldd	r27, Y+6	; 0x06
    7b32:	ed 91       	ld	r30, X+
    7b34:	be 83       	std	Y+6, r27	; 0x06
    7b36:	ad 83       	std	Y+5, r26	; 0x05
    7b38:	bf ef       	ldi	r27, 0xFF	; 255
    7b3a:	8b 1a       	sub	r8, r27
    7b3c:	9b 0a       	sbc	r9, r27
    7b3e:	ab 0a       	sbc	r10, r27
			boot_rww_enable();								// re-enable the RWW section

			/* verify data, compare source data segment only */
			uint8_t isValid = 1;
			for (uint8_t idx = 0; idx < len; ++idx) {
				const uint8_t ptrdata = (pgm_read_word_near((baddr + idx) & 0xfffe) >> (((baddr + idx) & 1) ?  8 : 0));
    7b40:	bb 0a       	sbc	r11, r27
    7b42:	02 c0       	rjmp	.+4      	; 0x7b48 <memory_bl_writeFlashPage+0x170>
    7b44:	96 95       	lsr	r25
    7b46:	87 95       	ror	r24
    7b48:	fa 95       	dec	r31
				if (ptrdata != source[sourceIdx + idx]) {
    7b4a:	e2 f7       	brpl	.-8      	; 0x7b44 <memory_bl_writeFlashPage+0x16c>
    7b4c:	e8 17       	cp	r30, r24
    7b4e:	11 f3       	breq	.-60     	; 0x7b14 <memory_bl_writeFlashPage+0x13c>
		if (!verifyCnt) {
			return;											// abort to write this page again
		}

		/* move pointers ahead */
		baddr     += len;
    7b50:	ab cf       	rjmp	.-170    	; 0x7aa8 <memory_bl_writeFlashPage+0xd0>
    7b52:	2c 0d       	add	r18, r12
    7b54:	3d 1d       	adc	r19, r13
    7b56:	4e 1d       	adc	r20, r14
		size      -= len;
    7b58:	5f 1d       	adc	r21, r15
		sourceIdx += len;
    7b5a:	67 1b       	sub	r22, r23
    7b5c:	07 0f       	add	r16, r23
	}
}
    7b5e:	58 cf       	rjmp	.-336    	; 0x7a10 <memory_bl_writeFlashPage+0x38>
    7b60:	27 96       	adiw	r28, 0x07	; 7
    7b62:	0f b6       	in	r0, 0x3f	; 63
    7b64:	f8 94       	cli
    7b66:	de bf       	out	0x3e, r29	; 62
    7b68:	0f be       	out	0x3f, r0	; 63
    7b6a:	cd bf       	out	0x3d, r28	; 61
    7b6c:	df 91       	pop	r29
    7b6e:	cf 91       	pop	r28
    7b70:	1f 91       	pop	r17
    7b72:	0f 91       	pop	r16
    7b74:	ff 90       	pop	r15
    7b76:	ef 90       	pop	r14
    7b78:	df 90       	pop	r13
    7b7a:	cf 90       	pop	r12
    7b7c:	bf 90       	pop	r11
    7b7e:	af 90       	pop	r10
    7b80:	9f 90       	pop	r9
    7b82:	8f 90       	pop	r8
    7b84:	7f 90       	pop	r7
    7b86:	6f 90       	pop	r6
    7b88:	5f 90       	pop	r5
    7b8a:	4f 90       	pop	r4
    7b8c:	3f 90       	pop	r3

#ifdef RELEASE
__attribute__((section(".df4iah_bl_memory"), aligned(2)))
#endif
void memory_bl_writeEEpromPage(uint8_t source[], pagebuf_t size, uint16_t baddr)
{
    7b8e:	2f 90       	pop	r2
    7b90:	08 95       	ret

00007b92 <memory_bl_writeEEpromPage>:
    7b92:	ef 92       	push	r14
    7b94:	ff 92       	push	r15
    7b96:	1f 93       	push	r17
    7b98:	cf 93       	push	r28
	uint8_t idx = 0;

	while (size--) {										// decrease number of bytes to write
    7b9a:	df 93       	push	r29
    7b9c:	7c 01       	movw	r14, r24
    7b9e:	c4 2f       	mov	r28, r20
    7ba0:	d5 2f       	mov	r29, r21
    7ba2:	16 2f       	mov	r17, r22
    7ba4:	14 0f       	add	r17, r20
		eeprom_write_byte((uint8_t*) baddr, source[idx++]);
    7ba6:	1c 17       	cp	r17, r28
    7ba8:	39 f0       	breq	.+14     	; 0x7bb8 <memory_bl_writeEEpromPage+0x26>
    7baa:	f7 01       	movw	r30, r14
    7bac:	61 91       	ld	r22, Z+
    7bae:	7f 01       	movw	r14, r30
		baddr++;											// select next byte
    7bb0:	ce 01       	movw	r24, r28
    7bb2:	a9 dd       	rcall	.-1198   	; 0x7706 <eeprom_write_byte>
	}														// loop until all bytes written

	// eeprom_busy_wait();
}
    7bb4:	21 96       	adiw	r28, 0x01	; 1
    7bb6:	f7 cf       	rjmp	.-18     	; 0x7ba6 <memory_bl_writeEEpromPage+0x14>
    7bb8:	df 91       	pop	r29
    7bba:	cf 91       	pop	r28
    7bbc:	1f 91       	pop	r17
    7bbe:	ff 90       	pop	r15
    7bc0:	ef 90       	pop	r14
    7bc2:	08 95       	ret

Disassembly of section .df4iah_bl_usb:

00007be0 <usb_bl_replyContent>:

#ifdef RELEASE
__attribute__((section(".df4iah_bl_usb"), aligned(2)))
#endif
void usb_bl_replyContent(uchar replyBuffer[], uchar data[])
{
    7be0:	fc 01       	movw	r30, r24
    7be2:	db 01       	movw	r26, r22
	replyBuffer[0] = data[2];
    7be4:	12 96       	adiw	r26, 0x02	; 2
    7be6:	8c 91       	ld	r24, X
    7be8:	12 97       	sbiw	r26, 0x02	; 2
    7bea:	80 83       	st	Z, r24
	replyBuffer[1] = data[3];
    7bec:	13 96       	adiw	r26, 0x03	; 3
    7bee:	8c 91       	ld	r24, X
    7bf0:	13 97       	sbiw	r26, 0x03	; 3
    7bf2:	81 83       	std	Z+1, r24	; 0x01
	replyBuffer[2] = data[4];
    7bf4:	14 96       	adiw	r26, 0x04	; 4
    7bf6:	8c 91       	ld	r24, X
    7bf8:	82 83       	std	Z+2, r24	; 0x02
    7bfa:	08 95       	ret

00007bfc <usb_bl_init>:
#ifdef RELEASE
__attribute__((section(".df4iah_bl_usb"), aligned(2)))
#endif
void usb_bl_init()
{
	usbInit();
    7bfc:	75 dd       	rcall	.-1302   	; 0x76e8 <usbInit>
	USB_INTR_ENABLE &= ~(_BV(USB_INTR_ENABLE_BIT));
    7bfe:	e8 98       	cbi	0x1d, 0	; 29
	usbDeviceDisconnect();			/* enforce re-enumeration, do this while interrupts are disabled! */
    7c00:	21 98       	cbi	0x04, 1	; 4
    7c02:	29 98       	cbi	0x05, 1	; 5

    uint8_t i = 250;
    while (--i) {											// fake USB disconnect for > 250 ms
    7c04:	8a ef       	ldi	r24, 0xFA	; 250
    7c06:	81 50       	subi	r24, 0x01	; 1
    7c08:	31 f0       	breq	.+12     	; 0x7c16 <usb_bl_init+0x1a>
    7c0a:	96 e0       	ldi	r25, 0x06	; 6
    7c0c:	9a 95       	dec	r25
    7c0e:	f1 f7       	brne	.-4      	; 0x7c0c <usb_bl_init+0x10>
    7c10:	00 c0       	rjmp	.+0      	; 0x7c12 <usb_bl_init+0x16>
        _delay_ms(1);
        wdt_reset();
    7c12:	a8 95       	wdr
    7c14:	f8 cf       	rjmp	.-16     	; 0x7c06 <usb_bl_init+0xa>
    }

    usbDeviceConnect();
    7c16:	21 9a       	sbi	0x04, 1	; 4
    7c18:	29 9a       	sbi	0x05, 1	; 5
	USB_INTR_ENABLE |= _BV(USB_INTR_ENABLE_BIT);
    7c1a:	e8 9a       	sbi	0x1d, 0	; 29
#ifdef RELEASE
__attribute__((section(".df4iah_bl_usb"), aligned(2)))
#endif
void usb_bl_close()
{
	USB_INTR_ENABLE &= ~(_BV(USB_INTR_ENABLE_BIT));
    7c1c:	08 95       	ret

00007c1e <usb_bl_close>:
	usbDeviceDisconnect();
    7c1e:	e8 98       	cbi	0x1d, 0	; 29
    7c20:	21 98       	cbi	0x04, 1	; 4

#ifdef RELEASE
__attribute__((section(".df4iah_bl_usb"), aligned(2)))
#endif
USB_PUBLIC usbMsgLen_t usbFunctionSetup(uchar data[8])
{
    7c22:	29 98       	cbi	0x05, 1	; 5
	const usbRequest_t* rq = (usbRequest_t*) data;
	uchar len = 0;

	if (rq->bRequest == USBASP_FUNC_CONNECT) {
    7c24:	08 95       	ret

00007c26 <usbFunctionSetup>:
    7c26:	dc 01       	movw	r26, r24
    7c28:	11 96       	adiw	r26, 0x01	; 1
    7c2a:	8c 91       	ld	r24, X
    7c2c:	11 97       	sbiw	r26, 0x01	; 1
		prog_connected = PROG_CONNECTED;
    7c2e:	81 30       	cpi	r24, 0x01	; 1
    7c30:	29 f4       	brne	.+10     	; 0x7c3c <usbFunctionSetup+0x16>

		/* set compatibility mode of address delivering */
		prog_address_newmode = 0;
    7c32:	80 93 0b 01 	sts	0x010B, r24	; 0x80010b <prog_connected>
    7c36:	10 92 09 01 	sts	0x0109, r1	; 0x800109 <prog_address_newmode>

	} else if (rq->bRequest == USBASP_FUNC_DISCONNECT) {
    7c3a:	2a c1       	rjmp	.+596    	; 0x7e90 <usbFunctionSetup+0x26a>
		prog_connected = PROG_UNCONNECTED;
    7c3c:	82 30       	cpi	r24, 0x02	; 2
    7c3e:	51 f4       	brne	.+20     	; 0x7c54 <usbFunctionSetup+0x2e>
		if (!mainIsJumperBlSet) {
    7c40:	10 92 0b 01 	sts	0x010B, r1	; 0x80010b <prog_connected>
    7c44:	80 91 03 01 	lds	r24, 0x0103	; 0x800103 <mainIsJumperBlSet>
			mainStopAvr = true;
    7c48:	81 11       	cpse	r24, r1
    7c4a:	22 c1       	rjmp	.+580    	; 0x7e90 <usbFunctionSetup+0x26a>
    7c4c:	81 e0       	ldi	r24, 0x01	; 1
    7c4e:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__data_end>
		}

	} else if (rq->bRequest == USBASP_FUNC_TRANSMIT) {
    7c52:	1e c1       	rjmp	.+572    	; 0x7e90 <usbFunctionSetup+0x26a>
    7c54:	83 30       	cpi	r24, 0x03	; 3
		if ((rq->wValue.word == 0x0030) && (rq->wIndex.bytes[0] < 3)) {
    7c56:	09 f0       	breq	.+2      	; 0x7c5a <usbFunctionSetup+0x34>
    7c58:	7b c0       	rjmp	.+246    	; 0x7d50 <usbFunctionSetup+0x12a>
    7c5a:	12 96       	adiw	r26, 0x02	; 2
    7c5c:	8d 91       	ld	r24, X+
    7c5e:	9c 91       	ld	r25, X
    7c60:	13 97       	sbiw	r26, 0x03	; 3
    7c62:	80 33       	cpi	r24, 0x30	; 48
    7c64:	91 05       	cpc	r25, r1
    7c66:	d9 f4       	brne	.+54     	; 0x7c9e <usbFunctionSetup+0x78>
    7c68:	14 96       	adiw	r26, 0x04	; 4
    7c6a:	ec 91       	ld	r30, X
    7c6c:	14 97       	sbiw	r26, 0x04	; 4
    7c6e:	e3 30       	cpi	r30, 0x03	; 3
#ifdef RELEASE
__attribute__((section(".df4iah_bl_usb"), aligned(2)))
#endif
void usb_bl_replyContent(uchar replyBuffer[], uchar data[])
{
	replyBuffer[0] = data[2];
    7c70:	08 f0       	brcs	.+2      	; 0x7c74 <usbFunctionSetup+0x4e>
    7c72:	0e c1       	rjmp	.+540    	; 0x7e90 <usbFunctionSetup+0x26a>
    7c74:	12 96       	adiw	r26, 0x02	; 2
    7c76:	8c 91       	ld	r24, X
    7c78:	12 97       	sbiw	r26, 0x02	; 2
	replyBuffer[1] = data[3];
    7c7a:	80 93 25 01 	sts	0x0125, r24	; 0x800125 <replyBuffer>
    7c7e:	13 96       	adiw	r26, 0x03	; 3
    7c80:	8c 91       	ld	r24, X
	replyBuffer[2] = data[4];
    7c82:	80 93 26 01 	sts	0x0126, r24	; 0x800126 <replyBuffer+0x1>

	} else if (rq->bRequest == USBASP_FUNC_TRANSMIT) {
		if ((rq->wValue.word == 0x0030) && (rq->wIndex.bytes[0] < 3)) {
			// signature bytes
			usb_bl_replyContent(replyBuffer, data);
			replyBuffer[3] = boot_signature_byte_get(data[4] << 1);
    7c86:	e0 93 27 01 	sts	0x0127, r30	; 0x800127 <replyBuffer+0x2>
    7c8a:	f0 e0       	ldi	r31, 0x00	; 0
    7c8c:	ee 0f       	add	r30, r30
    7c8e:	ff 1f       	adc	r31, r31
    7c90:	81 e2       	ldi	r24, 0x21	; 33
    7c92:	80 93 57 00 	sts	0x0057, r24	; 0x800057 <__TEXT_REGION_LENGTH__+0x7e0057>
    7c96:	e4 91       	lpm	r30, Z
    7c98:	e0 93 28 01 	sts	0x0128, r30	; 0x800128 <replyBuffer+0x3>
			len = 4;

		} else if (rq->wValue.word == 0x0050) {
    7c9c:	17 c1       	rjmp	.+558    	; 0x7ecc <usbFunctionSetup+0x2a6>
    7c9e:	80 35       	cpi	r24, 0x50	; 80
#ifdef RELEASE
__attribute__((section(".df4iah_bl_usb"), aligned(2)))
#endif
void usb_bl_replyContent(uchar replyBuffer[], uchar data[])
{
	replyBuffer[0] = data[2];
    7ca0:	91 05       	cpc	r25, r1
    7ca2:	89 f4       	brne	.+34     	; 0x7cc6 <usbFunctionSetup+0xa0>
    7ca4:	12 96       	adiw	r26, 0x02	; 2
    7ca6:	8c 91       	ld	r24, X
    7ca8:	12 97       	sbiw	r26, 0x02	; 2
	replyBuffer[1] = data[3];
    7caa:	80 93 25 01 	sts	0x0125, r24	; 0x800125 <replyBuffer>
    7cae:	13 96       	adiw	r26, 0x03	; 3
    7cb0:	8c 91       	ld	r24, X
    7cb2:	13 97       	sbiw	r26, 0x03	; 3
	replyBuffer[2] = data[4];
    7cb4:	80 93 26 01 	sts	0x0126, r24	; 0x800126 <replyBuffer+0x1>
    7cb8:	14 96       	adiw	r26, 0x04	; 4
    7cba:	8c 91       	ld	r24, X
			len = 4;

		} else if (rq->wValue.word == 0x0050) {
			// lfuse bits - @see page 271f
			usb_bl_replyContent(replyBuffer, data);
			replyBuffer[3] = boot_lock_fuse_bits_get(GET_LOW_FUSE_BITS);
    7cbc:	80 93 27 01 	sts	0x0127, r24	; 0x800127 <replyBuffer+0x2>
    7cc0:	e0 e0       	ldi	r30, 0x00	; 0
			len = 4;

		} else if (rq->wValue.word == 0x0858) {
    7cc2:	f0 e0       	ldi	r31, 0x00	; 0
    7cc4:	3e c0       	rjmp	.+124    	; 0x7d42 <usbFunctionSetup+0x11c>
    7cc6:	88 35       	cpi	r24, 0x58	; 88
    7cc8:	28 e0       	ldi	r18, 0x08	; 8
#ifdef RELEASE
__attribute__((section(".df4iah_bl_usb"), aligned(2)))
#endif
void usb_bl_replyContent(uchar replyBuffer[], uchar data[])
{
	replyBuffer[0] = data[2];
    7cca:	92 07       	cpc	r25, r18
    7ccc:	89 f4       	brne	.+34     	; 0x7cf0 <usbFunctionSetup+0xca>
    7cce:	12 96       	adiw	r26, 0x02	; 2
    7cd0:	8c 91       	ld	r24, X
    7cd2:	12 97       	sbiw	r26, 0x02	; 2
	replyBuffer[1] = data[3];
    7cd4:	80 93 25 01 	sts	0x0125, r24	; 0x800125 <replyBuffer>
    7cd8:	13 96       	adiw	r26, 0x03	; 3
    7cda:	8c 91       	ld	r24, X
    7cdc:	13 97       	sbiw	r26, 0x03	; 3
	replyBuffer[2] = data[4];
    7cde:	80 93 26 01 	sts	0x0126, r24	; 0x800126 <replyBuffer+0x1>
    7ce2:	14 96       	adiw	r26, 0x04	; 4
    7ce4:	8c 91       	ld	r24, X
			len = 4;

		} else if (rq->wValue.word == 0x0858) {
			// hfuse bits
			usb_bl_replyContent(replyBuffer, data);
			replyBuffer[3] = boot_lock_fuse_bits_get(GET_HIGH_FUSE_BITS);
    7ce6:	80 93 27 01 	sts	0x0127, r24	; 0x800127 <replyBuffer+0x2>
    7cea:	e3 e0       	ldi	r30, 0x03	; 3
			len = 4;

		} else if (rq->wValue.word == 0x0850) {
    7cec:	f0 e0       	ldi	r31, 0x00	; 0
    7cee:	29 c0       	rjmp	.+82     	; 0x7d42 <usbFunctionSetup+0x11c>
    7cf0:	80 35       	cpi	r24, 0x50	; 80
    7cf2:	58 e0       	ldi	r21, 0x08	; 8
#ifdef RELEASE
__attribute__((section(".df4iah_bl_usb"), aligned(2)))
#endif
void usb_bl_replyContent(uchar replyBuffer[], uchar data[])
{
	replyBuffer[0] = data[2];
    7cf4:	95 07       	cpc	r25, r21
    7cf6:	89 f4       	brne	.+34     	; 0x7d1a <usbFunctionSetup+0xf4>
    7cf8:	12 96       	adiw	r26, 0x02	; 2
    7cfa:	8c 91       	ld	r24, X
    7cfc:	12 97       	sbiw	r26, 0x02	; 2
	replyBuffer[1] = data[3];
    7cfe:	80 93 25 01 	sts	0x0125, r24	; 0x800125 <replyBuffer>
    7d02:	13 96       	adiw	r26, 0x03	; 3
    7d04:	8c 91       	ld	r24, X
    7d06:	13 97       	sbiw	r26, 0x03	; 3
	replyBuffer[2] = data[4];
    7d08:	80 93 26 01 	sts	0x0126, r24	; 0x800126 <replyBuffer+0x1>
    7d0c:	14 96       	adiw	r26, 0x04	; 4
    7d0e:	8c 91       	ld	r24, X
			len = 4;

		} else if (rq->wValue.word == 0x0850) {
			// efuse bits
			usb_bl_replyContent(replyBuffer, data);
			replyBuffer[3] = boot_lock_fuse_bits_get(GET_EXTENDED_FUSE_BITS);
    7d10:	80 93 27 01 	sts	0x0127, r24	; 0x800127 <replyBuffer+0x2>
    7d14:	e2 e0       	ldi	r30, 0x02	; 2
			len = 4;

		} else if (rq->wValue.word == 0x0058) {
    7d16:	f0 e0       	ldi	r31, 0x00	; 0
    7d18:	14 c0       	rjmp	.+40     	; 0x7d42 <usbFunctionSetup+0x11c>
    7d1a:	88 35       	cpi	r24, 0x58	; 88
    7d1c:	91 05       	cpc	r25, r1
#ifdef RELEASE
__attribute__((section(".df4iah_bl_usb"), aligned(2)))
#endif
void usb_bl_replyContent(uchar replyBuffer[], uchar data[])
{
	replyBuffer[0] = data[2];
    7d1e:	09 f0       	breq	.+2      	; 0x7d22 <usbFunctionSetup+0xfc>
    7d20:	b7 c0       	rjmp	.+366    	; 0x7e90 <usbFunctionSetup+0x26a>
    7d22:	12 96       	adiw	r26, 0x02	; 2
    7d24:	8c 91       	ld	r24, X
    7d26:	12 97       	sbiw	r26, 0x02	; 2
	replyBuffer[1] = data[3];
    7d28:	80 93 25 01 	sts	0x0125, r24	; 0x800125 <replyBuffer>
    7d2c:	13 96       	adiw	r26, 0x03	; 3
    7d2e:	8c 91       	ld	r24, X
    7d30:	13 97       	sbiw	r26, 0x03	; 3
	replyBuffer[2] = data[4];
    7d32:	80 93 26 01 	sts	0x0126, r24	; 0x800126 <replyBuffer+0x1>
    7d36:	14 96       	adiw	r26, 0x04	; 4
    7d38:	8c 91       	ld	r24, X
			len = 4;

		} else if (rq->wValue.word == 0x0058) {
			// lock bits
			usb_bl_replyContent(replyBuffer, data);
			replyBuffer[3] = boot_lock_fuse_bits_get(GET_LOCK_BITS);
    7d3a:	80 93 27 01 	sts	0x0127, r24	; 0x800127 <replyBuffer+0x2>
    7d3e:	e1 e0       	ldi	r30, 0x01	; 1
    7d40:	f0 e0       	ldi	r31, 0x00	; 0
    7d42:	89 e0       	ldi	r24, 0x09	; 9
    7d44:	80 93 57 00 	sts	0x0057, r24	; 0x800057 <__TEXT_REGION_LENGTH__+0x7e0057>
    7d48:	84 91       	lpm	r24, Z
    7d4a:	80 93 28 01 	sts	0x0128, r24	; 0x800128 <replyBuffer+0x3>
			len = 4;
		}

	} else if ((rq->bRequest == USBASP_FUNC_READFLASH) || (rq->bRequest == USBASP_FUNC_READEEPROM)) {
    7d4e:	be c0       	rjmp	.+380    	; 0x7ecc <usbFunctionSetup+0x2a6>
    7d50:	84 30       	cpi	r24, 0x04	; 4
    7d52:	11 f0       	breq	.+4      	; 0x7d58 <usbFunctionSetup+0x132>
		if (prog_connected > PROG_UNCONNECTED) {
    7d54:	87 30       	cpi	r24, 0x07	; 7
    7d56:	39 f5       	brne	.+78     	; 0x7da6 <usbFunctionSetup+0x180>
    7d58:	90 91 0b 01 	lds	r25, 0x010B	; 0x80010b <prog_connected>
    7d5c:	99 23       	and	r25, r25
			if (!prog_address_newmode) {
    7d5e:	09 f4       	brne	.+2      	; 0x7d62 <usbFunctionSetup+0x13c>
    7d60:	97 c0       	rjmp	.+302    	; 0x7e90 <usbFunctionSetup+0x26a>
    7d62:	90 91 09 01 	lds	r25, 0x0109	; 0x800109 <prog_address_newmode>
				prog_address = rq->wValue.word;
    7d66:	91 11       	cpse	r25, r1
    7d68:	0e c0       	rjmp	.+28     	; 0x7d86 <usbFunctionSetup+0x160>
    7d6a:	12 96       	adiw	r26, 0x02	; 2
    7d6c:	4d 91       	ld	r20, X+
    7d6e:	5c 91       	ld	r21, X
    7d70:	13 97       	sbiw	r26, 0x03	; 3
    7d72:	60 e0       	ldi	r22, 0x00	; 0
    7d74:	70 e0       	ldi	r23, 0x00	; 0
    7d76:	40 93 2e 01 	sts	0x012E, r20	; 0x80012e <prog_address>
    7d7a:	50 93 2f 01 	sts	0x012F, r21	; 0x80012f <prog_address+0x1>
    7d7e:	60 93 30 01 	sts	0x0130, r22	; 0x800130 <prog_address+0x2>
			}

			prog_nbytes = rq->wLength.word;
    7d82:	70 93 31 01 	sts	0x0131, r23	; 0x800131 <prog_address+0x3>
    7d86:	16 96       	adiw	r26, 0x06	; 6
    7d88:	2d 91       	ld	r18, X+
    7d8a:	3c 91       	ld	r19, X
    7d8c:	17 97       	sbiw	r26, 0x07	; 7
    7d8e:	30 93 08 01 	sts	0x0108, r19	; 0x800108 <prog_nbytes+0x1>
			prog_state = (rq->bRequest == USBASP_FUNC_READFLASH) ?  PROG_STATE_READFLASH : PROG_STATE_READEEPROM;
    7d92:	20 93 07 01 	sts	0x0107, r18	; 0x800107 <prog_nbytes>
    7d96:	84 30       	cpi	r24, 0x04	; 4
    7d98:	11 f0       	breq	.+4      	; 0x7d9e <usbFunctionSetup+0x178>
    7d9a:	83 e0       	ldi	r24, 0x03	; 3
    7d9c:	01 c0       	rjmp	.+2      	; 0x7da0 <usbFunctionSetup+0x17a>
    7d9e:	82 e0       	ldi	r24, 0x02	; 2
    7da0:	80 93 0a 01 	sts	0x010A, r24	; 0x80010a <prog_state>
			len = 0xff; /* multiple in */
		}

	} else if (rq->bRequest == USBASP_FUNC_ENABLEPROG) {
    7da4:	95 c0       	rjmp	.+298    	; 0x7ed0 <usbFunctionSetup+0x2aa>
		if (prog_connected == PROG_CONNECTED) {
    7da6:	85 30       	cpi	r24, 0x05	; 5
    7da8:	61 f4       	brne	.+24     	; 0x7dc2 <usbFunctionSetup+0x19c>
    7daa:	80 91 0b 01 	lds	r24, 0x010B	; 0x80010b <prog_connected>
			prog_connected = PROG_PROGENABLED;
    7dae:	81 30       	cpi	r24, 0x01	; 1
    7db0:	21 f4       	brne	.+8      	; 0x7dba <usbFunctionSetup+0x194>
    7db2:	82 e0       	ldi	r24, 0x02	; 2
    7db4:	80 93 0b 01 	sts	0x010B, r24	; 0x80010b <prog_connected>
			replyBuffer[0] = 0;
		} else {
			replyBuffer[0] = 1;
    7db8:	6f c0       	rjmp	.+222    	; 0x7e98 <usbFunctionSetup+0x272>
    7dba:	81 e0       	ldi	r24, 0x01	; 1
    7dbc:	80 93 25 01 	sts	0x0125, r24	; 0x800125 <replyBuffer>
		}
		len = 1;

	} else if ((rq->bRequest == USBASP_FUNC_WRITEFLASH) || (rq->bRequest == USBASP_FUNC_WRITEEEPROM)) {
    7dc0:	88 c0       	rjmp	.+272    	; 0x7ed2 <usbFunctionSetup+0x2ac>
    7dc2:	86 30       	cpi	r24, 0x06	; 6
    7dc4:	19 f0       	breq	.+6      	; 0x7dcc <usbFunctionSetup+0x1a6>
    7dc6:	88 30       	cpi	r24, 0x08	; 8
		if (prog_connected == PROG_PROGENABLED) {
    7dc8:	09 f0       	breq	.+2      	; 0x7dcc <usbFunctionSetup+0x1a6>
    7dca:	4b c0       	rjmp	.+150    	; 0x7e62 <usbFunctionSetup+0x23c>
    7dcc:	90 91 0b 01 	lds	r25, 0x010B	; 0x80010b <prog_connected>
    7dd0:	92 30       	cpi	r25, 0x02	; 2
			if (!prog_address_newmode) {
    7dd2:	09 f0       	breq	.+2      	; 0x7dd6 <usbFunctionSetup+0x1b0>
    7dd4:	5d c0       	rjmp	.+186    	; 0x7e90 <usbFunctionSetup+0x26a>
    7dd6:	90 91 09 01 	lds	r25, 0x0109	; 0x800109 <prog_address_newmode>
				prog_address = rq->wValue.word;
    7dda:	91 11       	cpse	r25, r1
    7ddc:	0e c0       	rjmp	.+28     	; 0x7dfa <usbFunctionSetup+0x1d4>
    7dde:	12 96       	adiw	r26, 0x02	; 2
    7de0:	4d 91       	ld	r20, X+
    7de2:	5c 91       	ld	r21, X
    7de4:	13 97       	sbiw	r26, 0x03	; 3
    7de6:	60 e0       	ldi	r22, 0x00	; 0
    7de8:	70 e0       	ldi	r23, 0x00	; 0
    7dea:	40 93 2e 01 	sts	0x012E, r20	; 0x80012e <prog_address>
    7dee:	50 93 2f 01 	sts	0x012F, r21	; 0x80012f <prog_address+0x1>
    7df2:	60 93 30 01 	sts	0x0130, r22	; 0x800130 <prog_address+0x2>
			}

			if (rq->bRequest == USBASP_FUNC_WRITEFLASH) {
    7df6:	70 93 31 01 	sts	0x0131, r23	; 0x800131 <prog_address+0x3>
				prog_blockflags = data[5] & 0x0F;
    7dfa:	86 30       	cpi	r24, 0x06	; 6
    7dfc:	01 f5       	brne	.+64     	; 0x7e3e <usbFunctionSetup+0x218>
    7dfe:	15 96       	adiw	r26, 0x05	; 5
    7e00:	4c 91       	ld	r20, X
    7e02:	15 97       	sbiw	r26, 0x05	; 5
    7e04:	84 2f       	mov	r24, r20
    7e06:	8f 70       	andi	r24, 0x0F	; 15
				prog_pagesize |= (((unsigned int) data[5] & 0xF0) << 4) | data[4];
    7e08:	80 93 32 01 	sts	0x0132, r24	; 0x800132 <prog_blockflags>
    7e0c:	14 96       	adiw	r26, 0x04	; 4
    7e0e:	2c 91       	ld	r18, X
    7e10:	14 97       	sbiw	r26, 0x04	; 4
    7e12:	80 91 33 01 	lds	r24, 0x0133	; 0x800133 <prog_pagesize>
    7e16:	90 91 34 01 	lds	r25, 0x0134	; 0x800134 <prog_pagesize+0x1>
    7e1a:	82 2b       	or	r24, r18
    7e1c:	24 2f       	mov	r18, r20
    7e1e:	20 7f       	andi	r18, 0xF0	; 240
    7e20:	50 e1       	ldi	r21, 0x10	; 16
    7e22:	25 9f       	mul	r18, r21
    7e24:	90 01       	movw	r18, r0
    7e26:	11 24       	eor	r1, r1
    7e28:	82 2b       	or	r24, r18
    7e2a:	93 2b       	or	r25, r19
    7e2c:	90 93 34 01 	sts	0x0134, r25	; 0x800134 <prog_pagesize+0x1>
				if (prog_blockflags & PROG_BLOCKFLAG_FIRST) {
    7e30:	80 93 33 01 	sts	0x0133, r24	; 0x800133 <prog_pagesize>
					prog_pagecounter = prog_pagesize;
    7e34:	40 fd       	sbrc	r20, 0
				}
				prog_state = PROG_STATE_WRITEFLASH;
    7e36:	80 93 2d 01 	sts	0x012D, r24	; 0x80012d <prog_pagecounter>

			} else {  /* data[1] == USBASP_FUNC_WRITEEEPROM */
				prog_pagesize = 0;
    7e3a:	81 e0       	ldi	r24, 0x01	; 1
    7e3c:	07 c0       	rjmp	.+14     	; 0x7e4c <usbFunctionSetup+0x226>
    7e3e:	10 92 34 01 	sts	0x0134, r1	; 0x800134 <prog_pagesize+0x1>
				prog_blockflags = 0;
    7e42:	10 92 33 01 	sts	0x0133, r1	; 0x800133 <prog_pagesize>
				prog_state = PROG_STATE_WRITEEEPROM;
    7e46:	10 92 32 01 	sts	0x0132, r1	; 0x800132 <prog_blockflags>
    7e4a:	84 e0       	ldi	r24, 0x04	; 4
			}

			prog_nbytes = rq->wLength.word;
    7e4c:	80 93 0a 01 	sts	0x010A, r24	; 0x80010a <prog_state>
    7e50:	16 96       	adiw	r26, 0x06	; 6
    7e52:	8d 91       	ld	r24, X+
    7e54:	9c 91       	ld	r25, X
    7e56:	17 97       	sbiw	r26, 0x07	; 7
    7e58:	90 93 08 01 	sts	0x0108, r25	; 0x800108 <prog_nbytes+0x1>
    7e5c:	80 93 07 01 	sts	0x0107, r24	; 0x800107 <prog_nbytes>
			len = 0xff; /* multiple out */
		}

	} else if (rq->bRequest == USBASP_FUNC_SETLONGADDRESS) {
    7e60:	37 c0       	rjmp	.+110    	; 0x7ed0 <usbFunctionSetup+0x2aa>
		if (prog_connected > PROG_UNCONNECTED) {
    7e62:	89 30       	cpi	r24, 0x09	; 9
    7e64:	b9 f4       	brne	.+46     	; 0x7e94 <usbFunctionSetup+0x26e>
    7e66:	80 91 0b 01 	lds	r24, 0x010B	; 0x80010b <prog_connected>
			/* set new mode of address delivering (ignore address delivered in commands) */
			prog_address_newmode = 1;
    7e6a:	88 23       	and	r24, r24
    7e6c:	89 f0       	breq	.+34     	; 0x7e90 <usbFunctionSetup+0x26a>
    7e6e:	81 e0       	ldi	r24, 0x01	; 1
			/* set new address */
			prog_address = rq->wValue.word;
    7e70:	80 93 09 01 	sts	0x0109, r24	; 0x800109 <prog_address_newmode>
    7e74:	12 96       	adiw	r26, 0x02	; 2
    7e76:	8d 91       	ld	r24, X+
    7e78:	9c 91       	ld	r25, X
    7e7a:	13 97       	sbiw	r26, 0x03	; 3
    7e7c:	a0 e0       	ldi	r26, 0x00	; 0
    7e7e:	b0 e0       	ldi	r27, 0x00	; 0
    7e80:	80 93 2e 01 	sts	0x012E, r24	; 0x80012e <prog_address>
    7e84:	90 93 2f 01 	sts	0x012F, r25	; 0x80012f <prog_address+0x1>
    7e88:	a0 93 30 01 	sts	0x0130, r26	; 0x800130 <prog_address+0x2>
__attribute__((section(".df4iah_bl_usb"), aligned(2)))
#endif
USB_PUBLIC usbMsgLen_t usbFunctionSetup(uchar data[8])
{
	const usbRequest_t* rq = (usbRequest_t*) data;
	uchar len = 0;
    7e8c:	b0 93 31 01 	sts	0x0131, r27	; 0x800131 <prog_address+0x3>
			prog_address_newmode = 1;
			/* set new address */
			prog_address = rq->wValue.word;
		}

	} else if (rq->bRequest == USBASP_FUNC_SETISPSCK) {
    7e90:	80 e0       	ldi	r24, 0x00	; 0
    7e92:	1f c0       	rjmp	.+62     	; 0x7ed2 <usbFunctionSetup+0x2ac>
		/* LOC does not implement that */
		replyBuffer[0] = 0;
    7e94:	8a 30       	cpi	r24, 0x0A	; 10
    7e96:	21 f4       	brne	.+8      	; 0x7ea0 <usbFunctionSetup+0x27a>
		len = 1;
    7e98:	10 92 25 01 	sts	0x0125, r1	; 0x800125 <replyBuffer>

	} else if (rq->bRequest == USBASP_FUNC_TPI_CONNECT) {
    7e9c:	81 e0       	ldi	r24, 0x01	; 1
    7e9e:	19 c0       	rjmp	.+50     	; 0x7ed2 <usbFunctionSetup+0x2ac>
    7ea0:	95 ef       	ldi	r25, 0xF5	; 245
    7ea2:	98 0f       	add	r25, r24
		/* Tiny Programming Interface is not supported */

	} else if (rq->bRequest == USBASP_FUNC_TPI_DISCONNECT) {
		/* Tiny Programming Interface is not supported */

	} else if (rq->bRequest == USBASP_FUNC_TPI_RAWREAD) {
    7ea4:	92 30       	cpi	r25, 0x02	; 2
    7ea6:	a0 f3       	brcs	.-24     	; 0x7e90 <usbFunctionSetup+0x26a>
		/* Tiny Programming Interface is not supported */
		replyBuffer[0] = 0;
		len = 1;

	} else if (rq->bRequest == USBASP_FUNC_TPI_RAWWRITE) {
    7ea8:	8d 30       	cpi	r24, 0x0D	; 13
    7eaa:	b1 f3       	breq	.-20     	; 0x7e98 <usbFunctionSetup+0x272>
		/* Tiny Programming Interface is not supported */

	} else if (rq->bRequest == USBASP_FUNC_TPI_READBLOCK) {
    7eac:	8e 30       	cpi	r24, 0x0E	; 14
    7eae:	81 f3       	breq	.-32     	; 0x7e90 <usbFunctionSetup+0x26a>
    7eb0:	91 ef       	ldi	r25, 0xF1	; 241
    7eb2:	98 0f       	add	r25, r24

	} else if (rq->bRequest == USBASP_FUNC_TPI_WRITEBLOCK) {
		/* Tiny Programming Interface is not supported */
		len = 0xff; /* multiple out */

	} else if (rq->bRequest == USBASP_FUNC_GETCAPABILITIES) {
    7eb4:	92 30       	cpi	r25, 0x02	; 2
    7eb6:	60 f0       	brcs	.+24     	; 0x7ed0 <usbFunctionSetup+0x2aa>
		/* Tiny Programming Interface is not supported */
		replyBuffer[3] = replyBuffer[2] = replyBuffer[1] = replyBuffer[0] = 0;  // USBASP_CAP_0_TPI;
    7eb8:	8f 37       	cpi	r24, 0x7F	; 127
    7eba:	51 f7       	brne	.-44     	; 0x7e90 <usbFunctionSetup+0x26a>
    7ebc:	10 92 25 01 	sts	0x0125, r1	; 0x800125 <replyBuffer>
    7ec0:	10 92 26 01 	sts	0x0126, r1	; 0x800126 <replyBuffer+0x1>
    7ec4:	10 92 27 01 	sts	0x0127, r1	; 0x800127 <replyBuffer+0x2>
		len = 4;
    7ec8:	10 92 28 01 	sts	0x0128, r1	; 0x800128 <replyBuffer+0x3>
	} else if (rq->bRequest == USBASP_FUNC_TPI_RAWWRITE) {
		/* Tiny Programming Interface is not supported */

	} else if (rq->bRequest == USBASP_FUNC_TPI_READBLOCK) {
		/* Tiny Programming Interface is not supported */
		len = 0xff; /* multiple in */
    7ecc:	84 e0       	ldi	r24, 0x04	; 4
		/* Tiny Programming Interface is not supported */
		replyBuffer[3] = replyBuffer[2] = replyBuffer[1] = replyBuffer[0] = 0;  // USBASP_CAP_0_TPI;
		len = 4;
	}

	usbMsgPtr = (usbMsgPtr_t) replyBuffer;
    7ece:	01 c0       	rjmp	.+2      	; 0x7ed2 <usbFunctionSetup+0x2ac>
    7ed0:	8f ef       	ldi	r24, 0xFF	; 255
    7ed2:	25 e2       	ldi	r18, 0x25	; 37
    7ed4:	31 e0       	ldi	r19, 0x01	; 1
    7ed6:	30 93 45 01 	sts	0x0145, r19	; 0x800145 <usbMsgPtr+0x1>

#ifdef RELEASE
__attribute__((section(".df4iah_bl_usb"), aligned(2)))
#endif
USB_PUBLIC uchar usbFunctionRead(uchar *data, uchar len)
{
    7eda:	20 93 44 01 	sts	0x0144, r18	; 0x800144 <usbMsgPtr>
	/* check if programmer is in correct read state */
	if ((prog_state != PROG_STATE_READFLASH) &&
    7ede:	08 95       	ret

00007ee0 <usbFunctionRead>:
    7ee0:	cf 93       	push	r28
    7ee2:	20 91 0a 01 	lds	r18, 0x010A	; 0x80010a <prog_state>
    7ee6:	3e ef       	ldi	r19, 0xFE	; 254
    7ee8:	32 0f       	add	r19, r18
		(prog_state	!= PROG_STATE_READEEPROM)) {
		return 0xff;
	}

	if (prog_state == PROG_STATE_READFLASH) {
    7eea:	32 30       	cpi	r19, 0x02	; 2
    7eec:	58 f5       	brcc	.+86     	; 0x7f44 <usbFunctionRead+0x64>
		memory_bl_readFlashPage(data, len, prog_address);
    7eee:	c6 2f       	mov	r28, r22
    7ef0:	22 30       	cpi	r18, 0x02	; 2
    7ef2:	51 f4       	brne	.+20     	; 0x7f08 <usbFunctionRead+0x28>
    7ef4:	20 91 2e 01 	lds	r18, 0x012E	; 0x80012e <prog_address>
    7ef8:	30 91 2f 01 	lds	r19, 0x012F	; 0x80012f <prog_address+0x1>
    7efc:	40 91 30 01 	lds	r20, 0x0130	; 0x800130 <prog_address+0x2>
    7f00:	50 91 31 01 	lds	r21, 0x0131	; 0x800131 <prog_address+0x3>
	} else {
		memory_bl_readEEpromPage(data, len, prog_address);
    7f04:	11 dd       	rcall	.-1502   	; 0x7928 <memory_bl_readFlashPage>
    7f06:	05 c0       	rjmp	.+10     	; 0x7f12 <usbFunctionRead+0x32>
    7f08:	40 91 2e 01 	lds	r20, 0x012E	; 0x80012e <prog_address>
	}
	prog_address += len;
    7f0c:	50 91 2f 01 	lds	r21, 0x012F	; 0x80012f <prog_address+0x1>
    7f10:	41 dd       	rcall	.-1406   	; 0x7994 <memory_bl_readEEpromPage>
    7f12:	80 91 2e 01 	lds	r24, 0x012E	; 0x80012e <prog_address>
    7f16:	90 91 2f 01 	lds	r25, 0x012F	; 0x80012f <prog_address+0x1>
    7f1a:	a0 91 30 01 	lds	r26, 0x0130	; 0x800130 <prog_address+0x2>
    7f1e:	b0 91 31 01 	lds	r27, 0x0131	; 0x800131 <prog_address+0x3>
    7f22:	8c 0f       	add	r24, r28
    7f24:	91 1d       	adc	r25, r1
    7f26:	a1 1d       	adc	r26, r1
    7f28:	b1 1d       	adc	r27, r1
    7f2a:	80 93 2e 01 	sts	0x012E, r24	; 0x80012e <prog_address>
    7f2e:	90 93 2f 01 	sts	0x012F, r25	; 0x80012f <prog_address+0x1>
    7f32:	a0 93 30 01 	sts	0x0130, r26	; 0x800130 <prog_address+0x2>

	/* last packet? */
	if (len < 8) {
    7f36:	b0 93 31 01 	sts	0x0131, r27	; 0x800131 <prog_address+0x3>
		prog_state = PROG_STATE_IDLE;
    7f3a:	c8 30       	cpi	r28, 0x08	; 8
    7f3c:	28 f4       	brcc	.+10     	; 0x7f48 <usbFunctionRead+0x68>
USB_PUBLIC uchar usbFunctionRead(uchar *data, uchar len)
{
	/* check if programmer is in correct read state */
	if ((prog_state != PROG_STATE_READFLASH) &&
		(prog_state	!= PROG_STATE_READEEPROM)) {
		return 0xff;
    7f3e:	10 92 0a 01 	sts	0x010A, r1	; 0x80010a <prog_state>
    7f42:	02 c0       	rjmp	.+4      	; 0x7f48 <usbFunctionRead+0x68>
	if (len < 8) {
		prog_state = PROG_STATE_IDLE;
	}

	return len;
}
    7f44:	8f ef       	ldi	r24, 0xFF	; 255
    7f46:	01 c0       	rjmp	.+2      	; 0x7f4a <usbFunctionRead+0x6a>

#ifdef RELEASE
__attribute__((section(".df4iah_bl_usb"), aligned(2)))
#endif
USB_PUBLIC uchar usbFunctionWrite(uchar *data, uchar len)
{
    7f48:	8c 2f       	mov	r24, r28
    7f4a:	cf 91       	pop	r28
	/* check if programmer is in correct write state */
	if ((prog_state != PROG_STATE_WRITEFLASH) &&
    7f4c:	08 95       	ret

00007f4e <usbFunctionWrite>:
    7f4e:	cf 93       	push	r28
    7f50:	c6 2f       	mov	r28, r22
    7f52:	20 91 0a 01 	lds	r18, 0x010A	; 0x80010a <prog_state>
    7f56:	21 30       	cpi	r18, 0x01	; 1
	}

	if (prog_state == PROG_STATE_WRITEFLASH) {
		memory_bl_writeFlashPage(data, len, prog_address);
	} else {
		memory_bl_writeEEpromPage(data, len, prog_address);
    7f58:	41 f0       	breq	.+16     	; 0x7f6a <usbFunctionWrite+0x1c>
    7f5a:	24 30       	cpi	r18, 0x04	; 4
    7f5c:	99 f5       	brne	.+102    	; 0x7fc4 <usbFunctionWrite+0x76>
    7f5e:	40 91 2e 01 	lds	r20, 0x012E	; 0x80012e <prog_address>
    7f62:	50 91 2f 01 	lds	r21, 0x012F	; 0x80012f <prog_address+0x1>
		(prog_state	!= PROG_STATE_WRITEEEPROM)) {
		return 0xff;
	}

	if (prog_state == PROG_STATE_WRITEFLASH) {
		memory_bl_writeFlashPage(data, len, prog_address);
    7f66:	15 de       	rcall	.-982    	; 0x7b92 <memory_bl_writeEEpromPage>
    7f68:	09 c0       	rjmp	.+18     	; 0x7f7c <usbFunctionWrite+0x2e>
    7f6a:	20 91 2e 01 	lds	r18, 0x012E	; 0x80012e <prog_address>
    7f6e:	30 91 2f 01 	lds	r19, 0x012F	; 0x80012f <prog_address+0x1>
    7f72:	40 91 30 01 	lds	r20, 0x0130	; 0x800130 <prog_address+0x2>
	} else {
		memory_bl_writeEEpromPage(data, len, prog_address);
	}
	prog_address += len;
    7f76:	50 91 31 01 	lds	r21, 0x0131	; 0x800131 <prog_address+0x3>
    7f7a:	2e dd       	rcall	.-1444   	; 0x79d8 <memory_bl_writeFlashPage>
    7f7c:	80 91 2e 01 	lds	r24, 0x012E	; 0x80012e <prog_address>
    7f80:	90 91 2f 01 	lds	r25, 0x012F	; 0x80012f <prog_address+0x1>
    7f84:	a0 91 30 01 	lds	r26, 0x0130	; 0x800130 <prog_address+0x2>
    7f88:	b0 91 31 01 	lds	r27, 0x0131	; 0x800131 <prog_address+0x3>
    7f8c:	8c 0f       	add	r24, r28
    7f8e:	91 1d       	adc	r25, r1
    7f90:	a1 1d       	adc	r26, r1
    7f92:	b1 1d       	adc	r27, r1
    7f94:	80 93 2e 01 	sts	0x012E, r24	; 0x80012e <prog_address>
    7f98:	90 93 2f 01 	sts	0x012F, r25	; 0x80012f <prog_address+0x1>
    7f9c:	a0 93 30 01 	sts	0x0130, r26	; 0x800130 <prog_address+0x2>

	prog_nbytes -= len;
    7fa0:	b0 93 31 01 	sts	0x0131, r27	; 0x800131 <prog_address+0x3>
    7fa4:	80 91 07 01 	lds	r24, 0x0107	; 0x800107 <prog_nbytes>
    7fa8:	90 91 08 01 	lds	r25, 0x0108	; 0x800108 <prog_nbytes+0x1>
    7fac:	8c 1b       	sub	r24, r28
    7fae:	91 09       	sbc	r25, r1
    7fb0:	90 93 08 01 	sts	0x0108, r25	; 0x800108 <prog_nbytes+0x1>
	if (prog_nbytes <= 0) {
    7fb4:	80 93 07 01 	sts	0x0107, r24	; 0x800107 <prog_nbytes>
		prog_state = PROG_STATE_IDLE;
    7fb8:	89 2b       	or	r24, r25
		return 1;
    7fba:	31 f4       	brne	.+12     	; 0x7fc8 <usbFunctionWrite+0x7a>
    7fbc:	10 92 0a 01 	sts	0x010A, r1	; 0x80010a <prog_state>
USB_PUBLIC uchar usbFunctionWrite(uchar *data, uchar len)
{
	/* check if programmer is in correct write state */
	if ((prog_state != PROG_STATE_WRITEFLASH) &&
		(prog_state	!= PROG_STATE_WRITEEEPROM)) {
		return 0xff;
    7fc0:	81 e0       	ldi	r24, 0x01	; 1
	if (prog_nbytes <= 0) {
		prog_state = PROG_STATE_IDLE;
		return 1;
	}

	return 0;
    7fc2:	03 c0       	rjmp	.+6      	; 0x7fca <usbFunctionWrite+0x7c>
}
    7fc4:	8f ef       	ldi	r24, 0xFF	; 255
    7fc6:	01 c0       	rjmp	.+2      	; 0x7fca <usbFunctionWrite+0x7c>
    7fc8:	80 e0       	ldi	r24, 0x00	; 0
    7fca:	cf 91       	pop	r28
    7fcc:	08 95       	ret

Disassembly of section .text:

00007000 <__vectors>:
    7000:	7a c0       	rjmp	.+244    	; 0x70f6 <__ctors_end>
    7002:	00 00       	nop
    7004:	bd c0       	rjmp	.+378    	; 0x7180 <__vector_1>
    7006:	00 00       	nop
    7008:	91 c0       	rjmp	.+290    	; 0x712c <__bad_interrupt>
    700a:	00 00       	nop
    700c:	8f c0       	rjmp	.+286    	; 0x712c <__bad_interrupt>
    700e:	00 00       	nop
    7010:	8d c0       	rjmp	.+282    	; 0x712c <__bad_interrupt>
    7012:	00 00       	nop
    7014:	8b c0       	rjmp	.+278    	; 0x712c <__bad_interrupt>
    7016:	00 00       	nop
    7018:	89 c0       	rjmp	.+274    	; 0x712c <__bad_interrupt>
    701a:	00 00       	nop
    701c:	87 c0       	rjmp	.+270    	; 0x712c <__bad_interrupt>
    701e:	00 00       	nop
    7020:	85 c0       	rjmp	.+266    	; 0x712c <__bad_interrupt>
    7022:	00 00       	nop
    7024:	83 c0       	rjmp	.+262    	; 0x712c <__bad_interrupt>
    7026:	00 00       	nop
    7028:	81 c0       	rjmp	.+258    	; 0x712c <__bad_interrupt>
    702a:	00 00       	nop
    702c:	7f c0       	rjmp	.+254    	; 0x712c <__bad_interrupt>
    702e:	00 00       	nop
    7030:	7d c0       	rjmp	.+250    	; 0x712c <__bad_interrupt>
    7032:	00 00       	nop
    7034:	7b c0       	rjmp	.+246    	; 0x712c <__bad_interrupt>
    7036:	00 00       	nop
    7038:	79 c0       	rjmp	.+242    	; 0x712c <__bad_interrupt>
    703a:	00 00       	nop
    703c:	77 c0       	rjmp	.+238    	; 0x712c <__bad_interrupt>
    703e:	00 00       	nop
    7040:	75 c0       	rjmp	.+234    	; 0x712c <__bad_interrupt>
    7042:	00 00       	nop
    7044:	73 c0       	rjmp	.+230    	; 0x712c <__bad_interrupt>
    7046:	00 00       	nop
    7048:	71 c0       	rjmp	.+226    	; 0x712c <__bad_interrupt>
    704a:	00 00       	nop
    704c:	6f c0       	rjmp	.+222    	; 0x712c <__bad_interrupt>
    704e:	00 00       	nop
    7050:	6d c0       	rjmp	.+218    	; 0x712c <__bad_interrupt>
    7052:	00 00       	nop
    7054:	6b c0       	rjmp	.+214    	; 0x712c <__bad_interrupt>
    7056:	00 00       	nop
    7058:	69 c0       	rjmp	.+210    	; 0x712c <__bad_interrupt>
    705a:	00 00       	nop
    705c:	67 c0       	rjmp	.+206    	; 0x712c <__bad_interrupt>
    705e:	00 00       	nop
    7060:	65 c0       	rjmp	.+202    	; 0x712c <__bad_interrupt>
    7062:	00 00       	nop
    7064:	63 c0       	rjmp	.+198    	; 0x712c <__bad_interrupt>
	...

00007068 <__trampolines_end>:
    7068:	09 02       	muls	r16, r25
    706a:	12 00       	.word	0x0012	; ????
    706c:	01 01       	movw	r0, r2
    706e:	00 80       	ld	r0, Z
    7070:	69 09       	sbc	r22, r9
    7072:	04 00       	.word	0x0004	; ????
    7074:	00 00       	nop
    7076:	00 00       	nop
	...

0000707a <usbDescriptorDevice>:
    707a:	12 01 10 01 ff 00 00 08 c0 16 dc 05 00 01 01 02     ................
    708a:	03 01                                               ..

0000708c <usbDescriptorStringSerialNumber>:
    708c:	10 03 50 00 72 00 6f 00 74 00 6f 00 2d 00 31 00     ..P.r.o.t.o.-.1.

0000709c <usbDescriptorStringDevice>:
    709c:	48 03 42 00 6f 00 6f 00 74 00 6c 00 6f 00 61 00     H.B.o.o.t.l.o.a.
    70ac:	64 00 65 00 72 00 20 00 66 00 6f 00 72 00 20 00     d.e.r. .f.o.r. .
    70bc:	44 00 46 00 34 00 49 00 41 00 48 00 2d 00 31 00     D.F.4.I.A.H.-.1.
    70cc:	30 00 4d 00 48 00 7a 00 2d 00 52 00 65 00 66 00     0.M.H.z.-.R.e.f.
    70dc:	2d 00 4f 00 73 00 63 00                             -.O.s.c.

000070e4 <usbDescriptorStringVendor>:
    70e4:	0e 03 44 00 46 00 34 00 49 00 41 00 48 00           ..D.F.4.I.A.H.

000070f2 <usbDescriptorString0>:
    70f2:	04 03 09 04                                         ....

000070f6 <__ctors_end>:
    70f6:	11 24       	eor	r1, r1
    70f8:	1f be       	out	0x3f, r1	; 63
    70fa:	cf ef       	ldi	r28, 0xFF	; 255
    70fc:	d8 e0       	ldi	r29, 0x08	; 8
    70fe:	de bf       	out	0x3e, r29	; 62
    7100:	cd bf       	out	0x3d, r28	; 61

00007102 <__do_copy_data>:
    7102:	11 e0       	ldi	r17, 0x01	; 1
    7104:	a0 e0       	ldi	r26, 0x00	; 0
    7106:	b1 e0       	ldi	r27, 0x01	; 1
    7108:	e6 e2       	ldi	r30, 0x26	; 38
    710a:	f7 e7       	ldi	r31, 0x77	; 119
    710c:	02 c0       	rjmp	.+4      	; 0x7112 <__do_copy_data+0x10>
    710e:	05 90       	lpm	r0, Z+
    7110:	0d 92       	st	X+, r0
    7112:	a2 30       	cpi	r26, 0x02	; 2
    7114:	b1 07       	cpc	r27, r17
    7116:	d9 f7       	brne	.-10     	; 0x710e <__do_copy_data+0xc>

00007118 <__do_clear_bss>:
    7118:	21 e0       	ldi	r18, 0x01	; 1
    711a:	a2 e0       	ldi	r26, 0x02	; 2
    711c:	b1 e0       	ldi	r27, 0x01	; 1
    711e:	01 c0       	rjmp	.+2      	; 0x7122 <.do_clear_bss_start>

00007120 <.do_clear_bss_loop>:
    7120:	1d 92       	st	X+, r1

00007122 <.do_clear_bss_start>:
    7122:	a0 36       	cpi	r26, 0x60	; 96
    7124:	b2 07       	cpc	r27, r18
    7126:	e1 f7       	brne	.-8      	; 0x7120 <.do_clear_bss_loop>
    7128:	41 d1       	rcall	.+642    	; 0x73ac <main>
    712a:	fb c2       	rjmp	.+1526   	; 0x7722 <_exit>

0000712c <__bad_interrupt>:
    712c:	69 cf       	rjmp	.-302    	; 0x7000 <__vectors>

0000712e <usbCrc16>:
;   byte    r18 / r22
;   scratch r23
;   resCrc  r24+r25 / r16+r17
;   ptr     X / Z
usbCrc16:
    mov     ptrL, argPtrL
    712e:	a8 2f       	mov	r26, r24
    mov     ptrH, argPtrH
    7130:	b9 2f       	mov	r27, r25
    ldi     resCrcL, 0xFF
    7132:	8f ef       	ldi	r24, 0xFF	; 255
    ldi     resCrcH, 0xFF
    7134:	9f ef       	ldi	r25, 0xFF	; 255
    rjmp    usbCrc16LoopTest
    7136:	1b c0       	rjmp	.+54     	; 0x716e <usbCrc16LoopTest>

00007138 <usbCrc16ByteLoop>:
usbCrc16ByteLoop:
    ld      byte, ptr+
    7138:	2d 91       	ld	r18, X+
    eor     resCrcL, byte   ; resCrcL is now 'x' in table()
    713a:	82 27       	eor	r24, r18
    mov     byte, resCrcL   ; compute parity of 'x'
    713c:	28 2f       	mov	r18, r24
    swap    byte
    713e:	22 95       	swap	r18
    eor     byte, resCrcL
    7140:	28 27       	eor	r18, r24
    mov     scratch, byte
    7142:	72 2f       	mov	r23, r18
    lsr     byte
    7144:	26 95       	lsr	r18
    lsr     byte
    7146:	26 95       	lsr	r18
    eor     byte, scratch
    7148:	27 27       	eor	r18, r23
    inc     byte
    714a:	23 95       	inc	r18
    lsr     byte
    714c:	26 95       	lsr	r18
    andi    byte, 1         ; byte is now parity(x)
    714e:	21 70       	andi	r18, 0x01	; 1
    mov     scratch, resCrcL
    7150:	78 2f       	mov	r23, r24
    mov     resCrcL, resCrcH
    7152:	89 2f       	mov	r24, r25
    eor     resCrcL, byte   ; low byte of if(parity(x)) value ^= 0xc001;
    7154:	82 27       	eor	r24, r18
    neg     byte
    7156:	21 95       	neg	r18
    andi    byte, 0xc0
    7158:	20 7c       	andi	r18, 0xC0	; 192
    mov     resCrcH, byte   ; high byte of if(parity(x)) value ^= 0xc001;
    715a:	92 2f       	mov	r25, r18
    clr     byte
    715c:	22 27       	eor	r18, r18
    lsr     scratch
    715e:	76 95       	lsr	r23
    ror     byte
    7160:	27 95       	ror	r18
    eor     resCrcH, scratch
    7162:	97 27       	eor	r25, r23
    eor     resCrcL, byte
    7164:	82 27       	eor	r24, r18
    lsr     scratch
    7166:	76 95       	lsr	r23
    ror     byte
    7168:	27 95       	ror	r18
    eor     resCrcH, scratch
    716a:	97 27       	eor	r25, r23
    eor     resCrcL, byte
    716c:	82 27       	eor	r24, r18

0000716e <usbCrc16LoopTest>:
usbCrc16LoopTest:
    subi    argLen, 1
    716e:	61 50       	subi	r22, 0x01	; 1
    brsh    usbCrc16ByteLoop
    7170:	18 f7       	brcc	.-58     	; 0x7138 <usbCrc16ByteLoop>
    com     resCrcL
    7172:	80 95       	com	r24
    com     resCrcH
    7174:	90 95       	com	r25
    ret
    7176:	08 95       	ret

00007178 <usbCrc16Append>:

#endif /* USB_USE_FAST_CRC */

; extern unsigned usbCrc16Append(unsigned char *data, unsigned char len);
usbCrc16Append:
    rcall   usbCrc16
    7178:	da df       	rcall	.-76     	; 0x712e <usbCrc16>
    st      ptr+, resCrcL
    717a:	8d 93       	st	X+, r24
    st      ptr+, resCrcH
    717c:	9d 93       	st	X+, r25
    ret
    717e:	08 95       	ret

00007180 <__vector_1>:
; bitcnt is used to determine when a stuff bit is due
; cnt holds the number of bytes left in the receive buffer

USB_INTR_VECTOR:
;order of registers pushed: YL, SREG YH, [sofError], bitcnt, shift, x1, x2, x3, x4, cnt
    push    YL                  ;[-28] push only what is necessary to sync with edge ASAP
    7180:	cf 93       	push	r28
    in      YL, SREG            ;[-26]
    7182:	cf b7       	in	r28, 0x3f	; 63
    push    YL                  ;[-25]
    7184:	cf 93       	push	r28
    push    YH                  ;[-23]
    7186:	df 93       	push	r29

00007188 <waitForJ>:
;sync up with J to K edge during sync pattern -- use fastest possible loops
;The first part waits at most 1 bit long since we must be in sync pattern.
;YL is guarenteed to be < 0x80 because I flag is clear. When we jump to
;waitForJ, ensure that this prerequisite is met.
waitForJ:
    inc     YL
    7188:	c3 95       	inc	r28
    sbis    USBIN, USBMINUS
    718a:	33 9b       	sbis	0x06, 3	; 6
    brne    waitForJ        ; just make sure we have ANY timeout
    718c:	e9 f7       	brne	.-6      	; 0x7188 <waitForJ>

0000718e <waitForK>:
waitForK:
;The following code results in a sampling window of < 1/4 bit which meets the spec.
    sbis    USBIN, USBMINUS     ;[-19]
    718e:	33 9b       	sbis	0x06, 3	; 6
    rjmp    foundK              ;[-18]
    7190:	19 c0       	rjmp	.+50     	; 0x71c4 <foundK>
    sbis    USBIN, USBMINUS
    7192:	33 9b       	sbis	0x06, 3	; 6
    rjmp    foundK
    7194:	17 c0       	rjmp	.+46     	; 0x71c4 <foundK>
    sbis    USBIN, USBMINUS
    7196:	33 9b       	sbis	0x06, 3	; 6
    rjmp    foundK
    7198:	15 c0       	rjmp	.+42     	; 0x71c4 <foundK>
    sbis    USBIN, USBMINUS
    719a:	33 9b       	sbis	0x06, 3	; 6
    rjmp    foundK
    719c:	13 c0       	rjmp	.+38     	; 0x71c4 <foundK>
    sbis    USBIN, USBMINUS
    719e:	33 9b       	sbis	0x06, 3	; 6
    rjmp    foundK
    71a0:	11 c0       	rjmp	.+34     	; 0x71c4 <foundK>
    sbis    USBIN, USBMINUS
    71a2:	33 9b       	sbis	0x06, 3	; 6
    rjmp    foundK
    71a4:	0f c0       	rjmp	.+30     	; 0x71c4 <foundK>
    sbis    USBIN, USBMINUS
    71a6:	33 9b       	sbis	0x06, 3	; 6
    rjmp    foundK
    71a8:	0d c0       	rjmp	.+26     	; 0x71c4 <foundK>
    sbis    USBIN, USBMINUS
    71aa:	33 9b       	sbis	0x06, 3	; 6
    rjmp    foundK
    71ac:	0b c0       	rjmp	.+22     	; 0x71c4 <foundK>
    sbis    USBIN, USBMINUS
    71ae:	33 9b       	sbis	0x06, 3	; 6
    rjmp    foundK
    71b0:	09 c0       	rjmp	.+18     	; 0x71c4 <foundK>
#if USB_COUNT_SOF
    lds     YL, usbSofCount
    71b2:	c0 91 43 01 	lds	r28, 0x0143	; 0x800143 <usbSofCount>
    inc     YL
    71b6:	c3 95       	inc	r28
    sts     usbSofCount, YL
    71b8:	c0 93 43 01 	sts	0x0143, r28	; 0x800143 <usbSofCount>
#endif  /* USB_COUNT_SOF */
#ifdef USB_SOF_HOOK
    USB_SOF_HOOK
    71bc:	c6 b5       	in	r28, 0x26	; 38
    71be:	c0 93 04 01 	sts	0x0104, r28	; 0x800104 <timer0Snapshot>
#endif
    rjmp    sofError
    71c2:	81 c0       	rjmp	.+258    	; 0x72c6 <sofError>

000071c4 <foundK>:
foundK:                         ;[-16]
;{3, 5} after falling D- edge, average delay: 4 cycles
;bit0 should be at 34 for center sampling. Currently at 4 so 30 cylces till bit 0 sample
;use 1 bit time for setup purposes, then sample again. Numbers in brackets
;are cycles from center of first sync (double K) bit after the instruction
    push    bitcnt              ;[-16]
    71c4:	6f 93       	push	r22
;   [---]                       ;[-15]
    lds     YL, usbInputBufOffset;[-14]
    71c6:	c0 91 42 01 	lds	r28, 0x0142	; 0x800142 <usbInputBufOffset>
;   [---]                       ;[-13]
    clr     YH                  ;[-12]
    71ca:	dd 27       	eor	r29, r29
    subi    YL, lo8(-(usbRxBuf));[-11] [rx loop init]
    71cc:	c6 5b       	subi	r28, 0xB6	; 182
    sbci    YH, hi8(-(usbRxBuf));[-10] [rx loop init]
    71ce:	de 4f       	sbci	r29, 0xFE	; 254
    push    shift               ;[-9]
    71d0:	2f 93       	push	r18
;   [---]                       ;[-8]
    ldi     shift,0x40          ;[-7] set msb to "1" so processing bit7 can be detected
    71d2:	20 e4       	ldi	r18, 0x40	; 64
    nop2                        ;[-6]
    71d4:	00 c0       	rjmp	.+0      	; 0x71d6 <foundK+0x12>
;   [---]                       ;[-5]
    ldi     bitcnt, 5           ;[-4] [rx loop init]
    71d6:	65 e0       	ldi	r22, 0x05	; 5
    sbis    USBIN, USBMINUS     ;[-3] we want two bits K (sample 3 cycles too early)
    71d8:	33 9b       	sbis	0x06, 3	; 6
    rjmp    haveTwoBitsK        ;[-2]
    71da:	03 c0       	rjmp	.+6      	; 0x71e2 <haveTwoBitsK>
    pop     shift               ;[-1] undo the push from before
    71dc:	2f 91       	pop	r18
    pop     bitcnt              ;[1] 
    71de:	6f 91       	pop	r22
    rjmp    waitForK            ;[3] this was not the end of sync, retry
    71e0:	d6 cf       	rjmp	.-84     	; 0x718e <waitForK>

000071e2 <haveTwoBitsK>:

;----------------------------------------------------------------------------
; push more registers and initialize values while we sample the first bits:
;----------------------------------------------------------------------------
haveTwoBitsK:
    push    x1                  ;[0]
    71e2:	0f 93       	push	r16
    push    x2                  ;[2]
    71e4:	1f 93       	push	r17
    push    x3                  ;[4] (leap2)
    71e6:	4f 93       	push	r20
    ldi     leap2, 0x55         ;[6] add leap cycle on 2nd,5th,8th,... stuff bit
    71e8:	45 e5       	ldi	r20, 0x55	; 85
    push    x4                  ;[7] == leap
    71ea:	5f 93       	push	r21
    ldi     leap, 0x55          ;[9] skip leap cycle on 2nd,5th,8th,... byte received
    71ec:	55 e5       	ldi	r21, 0x55	; 85
    push    cnt                 ;[10]
    71ee:	3f 93       	push	r19
    ldi     cnt, USB_BUFSIZE    ;[12] [rx loop init]
    71f0:	3b e0       	ldi	r19, 0x0B	; 11
    ldi     x2, 1<<USBPLUS      ;[13] current line state is K state. D+=="1", D-=="0"
    71f2:	14 e0       	ldi	r17, 0x04	; 4

000071f4 <bit0>:
bit0:       
    in      x1, USBIN           ;[0] sample line state
    71f4:	06 b1       	in	r16, 0x06	; 6
    andi    x1, USBMASK         ;[1] filter only D+ and D- bits
    71f6:	0c 70       	andi	r16, 0x0C	; 12
    rjmp    handleBit           ;[2] make bit0 14 cycles long
    71f8:	2e c0       	rjmp	.+92     	; 0x7256 <handleBit>

000071fa <b6checkUnstuff>:
;----------------------------------------------------------------------------
; Process bit7. However, bit 6 still may need unstuffing.
;----------------------------------------------------------------------------

b6checkUnstuff:
    dec     bitcnt              ;[9]
    71fa:	6a 95       	dec	r22
    breq    unstuff6            ;[10]
    71fc:	c9 f0       	breq	.+50     	; 0x7230 <unstuff6>

000071fe <bit7>:
bit7:
    subi    cnt, 1              ;[11] cannot use dec becaus it does not affect the carry flag
    71fe:	31 50       	subi	r19, 0x01	; 1
    brcs    overflow            ;[12] Too many bytes received. Ignore packet
    7200:	d8 f1       	brcs	.+118    	; 0x7278 <overflow>
    in      x1, USBIN           ;[0] sample line state
    7202:	06 b1       	in	r16, 0x06	; 6
    andi    x1, USBMASK         ;[1] filter only D+ and D- bits
    7204:	0c 70       	andi	r16, 0x0C	; 12
    cpse    x1, x2              ;[2] when previous line state equals current line state, handle "1"
    7206:	01 13       	cpse	r16, r17
    rjmp    b7handle0           ;[3] when line state differs, handle "0"
    7208:	0b c0       	rjmp	.+22     	; 0x7220 <b7handle0>
    sec                         ;[4]
    720a:	08 94       	sec
    ror     shift               ;[5] shift "1" into the data
    720c:	27 95       	ror	r18
    st      y+, shift           ;[6] store the data into the buffer
    720e:	29 93       	st	Y+, r18
    ldi     shift, 0x40         ;[7] reset data for receiving the next byte
    7210:	20 e4       	ldi	r18, 0x40	; 64
    subi    leap, 0x55          ;[9] trick to introduce a leap cycle every 3 bytes
    7212:	55 55       	subi	r21, 0x55	; 85
    brcc    nextInst            ;[10 or 11] it will fail after 85 bytes. However low speed can only receive 11
    7214:	00 f4       	brcc	.+0      	; 0x7216 <bit7+0x18>
    dec     bitcnt              ;[11 or 12]
    7216:	6a 95       	dec	r22
    brne    bit0                ;[12 or 13]
    7218:	69 f7       	brne	.-38     	; 0x71f4 <bit0>
    ldi     x1, 1               ;[13 or 14] unstuffing bit 7
    721a:	01 e0       	ldi	r16, 0x01	; 1
    in      bitcnt, USBIN       ;[0] sample stuff bit
    721c:	66 b1       	in	r22, 0x06	; 6
    rjmp    unstuff             ;[1]
    721e:	0b c0       	rjmp	.+22     	; 0x7236 <unstuff>

00007220 <b7handle0>:

b7handle0:
    mov     x2,x1               ;[5] Set x2 to current line state
    7220:	10 2f       	mov	r17, r16
    ldi     bitcnt, 6           ;[6]
    7222:	66 e0       	ldi	r22, 0x06	; 6
    lsr     shift               ;[7] shift "0" into the data
    7224:	26 95       	lsr	r18
    st      y+, shift           ;[8] store data into the buffer
    7226:	29 93       	st	Y+, r18
    ldi     shift, 0x40         ;[10] reset data for receiving the next byte
    7228:	20 e4       	ldi	r18, 0x40	; 64
    subi    leap, 0x55          ;[11] trick to introduce a leap cycle every 3 bytes
    722a:	55 55       	subi	r21, 0x55	; 85
    brcs    bit0                ;[12] it will fail after 85 bytes. However low speed can only receive 11
    722c:	18 f3       	brcs	.-58     	; 0x71f4 <bit0>
    rjmp    bit0                ;[13]
    722e:	e2 cf       	rjmp	.-60     	; 0x71f4 <bit0>

00007230 <unstuff6>:
; Handle unstuff
; x1==0xFF indicate unstuffing bit6
;----------------------------------------------------------------------------

unstuff6:
    ldi     x1,0xFF             ;[12] indicate unstuffing bit 6
    7230:	0f ef       	ldi	r16, 0xFF	; 255
    in      bitcnt, USBIN       ;[0]  sample stuff bit
    7232:	66 b1       	in	r22, 0x06	; 6
	...

00007236 <unstuff>:
    nop                         ;[1]  fix timing
unstuff:                        ;b0-5  b6   b7
    mov     x2,bitcnt           ;[3]  [2]  [3]  Set x2 to match line state
    7236:	16 2f       	mov	r17, r22
    subi    leap2, 0x55         ;[4]  [3]  [4]  delay loop
    7238:	45 55       	subi	r20, 0x55	; 85
    brcs    nextInst            ;[5]  [4]  [5]  add one cycle every three stuff bits
    723a:	00 f0       	brcs	.+0      	; 0x723c <unstuff+0x6>
    sbci    leap2,0             ;[6]  [5]  [6]
    723c:	40 40       	sbci	r20, 0x00	; 0
    ldi     bitcnt,6            ;[7]  [6]  [7]  reset bit stuff counter
    723e:	66 e0       	ldi	r22, 0x06	; 6
    andi    x2, USBMASK         ;[8]  [7]  [8] only keep D+ and D-
    7240:	1c 70       	andi	r17, 0x0C	; 12
    cpi     x1,0                ;[9]  [8]  [9]
    7242:	00 30       	cpi	r16, 0x00	; 0
    brmi    bit7                ;[10] [9]  [10] finished unstuffing bit6 When x1<0
    7244:	e2 f2       	brmi	.-72     	; 0x71fe <bit7>
    breq    bitloop             ;[11] ---  [11] finished unstuffing bit0-5 when x1=0
    7246:	21 f0       	breq	.+8      	; 0x7250 <bitloop>
    nop                         ;---  ---  [12]
    7248:	00 00       	nop
    in      x1, USBIN           ;---  ---  [0] sample line state for bit0
    724a:	06 b1       	in	r16, 0x06	; 6
    andi    x1, USBMASK         ;---  ---  [1] filter only D+ and D- bits
    724c:	0c 70       	andi	r16, 0x0C	; 12
    rjmp    handleBit           ;---  ---  [2] make bit0 14 cycles long
    724e:	03 c0       	rjmp	.+6      	; 0x7256 <handleBit>

00007250 <bitloop>:

;----------------------------------------------------------------------------
; Receiver loop (numbers in brackets are cycles within byte after instr)
;----------------------------------------------------------------------------
bitloop:
    in      x1, USBIN           ;[0] sample line state
    7250:	06 b1       	in	r16, 0x06	; 6
    andi    x1, USBMASK         ;[1] filter only D+ and D- bits
    7252:	0c 70       	andi	r16, 0x0C	; 12
    breq    se0                 ;[2] both lines are low so handle se0
    7254:	a9 f0       	breq	.+42     	; 0x7280 <se0>

00007256 <handleBit>:
handleBit:
    cpse    x1, x2              ;[3] when previous line state equals current line state, handle "1"
    7256:	01 13       	cpse	r16, r17
    rjmp    handle0             ;[4] when line state differs, handle "0"
    7258:	09 c0       	rjmp	.+18     	; 0x726c <handle0>
    sec                         ;[5]
    725a:	08 94       	sec
    ror     shift               ;[6] shift "1" into the data
    725c:	27 95       	ror	r18
    brcs    b6checkUnstuff      ;[7] When after shift C is set, next bit is bit7
    725e:	68 f2       	brcs	.-102    	; 0x71fa <b6checkUnstuff>
    nop2                        ;[8]
    7260:	00 c0       	rjmp	.+0      	; 0x7262 <handleBit+0xc>
    dec     bitcnt              ;[10]
    7262:	6a 95       	dec	r22
    brne    bitloop             ;[11]
    7264:	a9 f7       	brne	.-22     	; 0x7250 <bitloop>
    ldi     x1,0                ;[12] indicate unstuff for bit other than bit6 or bit7
    7266:	00 e0       	ldi	r16, 0x00	; 0
    in      bitcnt, USBIN       ;[0] sample stuff bit
    7268:	66 b1       	in	r22, 0x06	; 6
    rjmp    unstuff             ;[1]
    726a:	e5 cf       	rjmp	.-54     	; 0x7236 <unstuff>

0000726c <handle0>:

handle0:
    mov     x2, x1              ;[6] Set x2 to current line state
    726c:	10 2f       	mov	r17, r16
    ldi     bitcnt, 6           ;[7] reset unstuff counter. 
    726e:	66 e0       	ldi	r22, 0x06	; 6
    lsr     shift               ;[8] shift "0" into the data
    7270:	26 95       	lsr	r18
    brcs    bit7                ;[9] When after shift C is set, next bit is bit7
    7272:	28 f2       	brcs	.-118    	; 0x71fe <bit7>
    nop                         ;[10]
    7274:	00 00       	nop
    rjmp    bitloop             ;[11] 
    7276:	ec cf       	rjmp	.-40     	; 0x7250 <bitloop>

00007278 <overflow>:
*/

#define token   x1

overflow:
    ldi     x2, 1<<USB_INTR_PENDING_BIT
    7278:	11 e0       	ldi	r17, 0x01	; 1
    USB_STORE_PENDING(x2)       ; clear any pending interrupts
    727a:	1c bb       	out	0x1c, r17	; 28

0000727c <ignorePacket>:
ignorePacket:
    clr     token
    727c:	00 27       	eor	r16, r16
    rjmp    storeTokenAndReturn
    727e:	17 c0       	rjmp	.+46     	; 0x72ae <handleSetupOrOut>

00007280 <se0>:
; Processing of received packet (numbers in brackets are cycles after center of SE0)
;----------------------------------------------------------------------------
;This is the only non-error exit point for the software receiver loop
;we don't check any CRCs here because there is no time left.
se0:
    subi    cnt, USB_BUFSIZE    ;[5]
    7280:	3b 50       	subi	r19, 0x0B	; 11
    neg     cnt                 ;[6]
    7282:	31 95       	neg	r19
    sub     YL, cnt             ;[7]
    7284:	c3 1b       	sub	r28, r19
    sbci    YH, 0               ;[8]
    7286:	d0 40       	sbci	r29, 0x00	; 0
    ldi     x2, 1<<USB_INTR_PENDING_BIT ;[9]
    7288:	11 e0       	ldi	r17, 0x01	; 1
    USB_STORE_PENDING(x2)       ;[10] clear pending intr and check flag later. SE0 should be over.
    728a:	1c bb       	out	0x1c, r17	; 28
    ld      token, y            ;[11]
    728c:	08 81       	ld	r16, Y
    cpi     token, USBPID_DATA0 ;[13]
    728e:	03 3c       	cpi	r16, 0xC3	; 195
    breq    handleData          ;[14]
    7290:	f9 f0       	breq	.+62     	; 0x72d0 <handleData>
    cpi     token, USBPID_DATA1 ;[15]
    7292:	0b 34       	cpi	r16, 0x4B	; 75
    breq    handleData          ;[16]
    7294:	e9 f0       	breq	.+58     	; 0x72d0 <handleData>
    lds     shift, usbDeviceAddr;[17]
    7296:	20 91 40 01 	lds	r18, 0x0140	; 0x800140 <usbDeviceAddr>
    ldd     x2, y+1             ;[19] ADDR and 1 bit endpoint number
    729a:	19 81       	ldd	r17, Y+1	; 0x01
    lsl     x2                  ;[21] shift out 1 bit endpoint number
    729c:	11 0f       	add	r17, r17
    cpse    x2, shift           ;[22]
    729e:	12 13       	cpse	r17, r18
    rjmp    ignorePacket        ;[23]
    72a0:	ed cf       	rjmp	.-38     	; 0x727c <ignorePacket>
/* only compute endpoint number in x3 if required later */
#if USB_CFG_HAVE_INTRIN_ENDPOINT || USB_CFG_IMPLEMENT_FN_WRITEOUT
    ldd     x3, y+2             ;[24] endpoint number + crc
    rol     x3                  ;[26] shift in LSB of endpoint
#endif
    cpi     token, USBPID_IN    ;[27]
    72a2:	09 36       	cpi	r16, 0x69	; 105
    breq    handleIn            ;[28]
    72a4:	51 f1       	breq	.+84     	; 0x72fa <handleIn>
    cpi     token, USBPID_SETUP ;[29]
    72a6:	0d 32       	cpi	r16, 0x2D	; 45
    breq    handleSetupOrOut    ;[30]
    72a8:	11 f0       	breq	.+4      	; 0x72ae <handleSetupOrOut>
    cpi     token, USBPID_OUT   ;[31]
    72aa:	01 3e       	cpi	r16, 0xE1	; 225
    brne    ignorePacket        ;[32] must be ack, nak or whatever
    72ac:	39 f7       	brne	.-50     	; 0x727c <ignorePacket>

000072ae <handleSetupOrOut>:
    andi    x3, 0xf             ;[32]
    breq    storeTokenAndReturn ;[33]
    mov     token, x3           ;[34] indicate that this is endpoint x OUT
#endif
storeTokenAndReturn:
    sts     usbCurrentTok, token;[35]
    72ae:	00 93 48 01 	sts	0x0148, r16	; 0x800148 <usbCurrentTok>

000072b2 <doReturn>:
doReturn:
    POP_STANDARD                ;[37] 12...16 cycles
    72b2:	3f 91       	pop	r19
    72b4:	5f 91       	pop	r21
    72b6:	4f 91       	pop	r20
    72b8:	1f 91       	pop	r17
    72ba:	0f 91       	pop	r16
    72bc:	2f 91       	pop	r18
    72be:	6f 91       	pop	r22
    USB_LOAD_PENDING(YL)        ;[49]
    72c0:	cc b3       	in	r28, 0x1c	; 28
    sbrc    YL, USB_INTR_PENDING_BIT;[50] check whether data is already arriving
    72c2:	c0 fd       	sbrc	r28, 0
    rjmp    waitForJ            ;[51] save the pops and pushes -- a new interrupt is already pending
    72c4:	61 cf       	rjmp	.-318    	; 0x7188 <waitForJ>

000072c6 <sofError>:
sofError:
    POP_RETI                    ;macro call
    72c6:	df 91       	pop	r29
    72c8:	cf 91       	pop	r28
    72ca:	cf bf       	out	0x3f, r28	; 63
    72cc:	cf 91       	pop	r28
    reti
    72ce:	18 95       	reti

000072d0 <handleData>:

handleData:
#if USB_CFG_CHECK_CRC
    CRC_CLEANUP_AND_CHECK       ; jumps to ignorePacket if CRC error
#endif
    lds     shift, usbCurrentTok;[18]
    72d0:	20 91 48 01 	lds	r18, 0x0148	; 0x800148 <usbCurrentTok>
    tst     shift               ;[20]
    72d4:	22 23       	and	r18, r18
    breq    doReturn            ;[21]
    72d6:	69 f3       	breq	.-38     	; 0x72b2 <doReturn>
    lds     x2, usbRxLen        ;[22]
    72d8:	10 91 46 01 	lds	r17, 0x0146	; 0x800146 <usbRxLen>
    tst     x2                  ;[24]
    72dc:	11 23       	and	r17, r17
    brne    sendNakAndReti      ;[25]
    72de:	29 f5       	brne	.+74     	; 0x732a <sendNakAndReti>
; 2006-03-11: The following two lines fix a problem where the device was not
; recognized if usbPoll() was called less frequently than once every 4 ms.
    cpi     cnt, 4              ;[26] zero sized data packets are status phase only -- ignore and ack
    72e0:	34 30       	cpi	r19, 0x04	; 4
    brmi    sendAckAndReti      ;[27] keep rx buffer clean -- we must not NAK next SETUP
    72e2:	2a f1       	brmi	.+74     	; 0x732e <sendAckAndReti>
#if USB_CFG_CHECK_DATA_TOGGLING
    sts     usbCurrentDataToken, token  ; store for checking by C code
#endif
    sts     usbRxLen, cnt       ;[28] store received data, swap buffers
    72e4:	30 93 46 01 	sts	0x0146, r19	; 0x800146 <usbRxLen>
    sts     usbRxToken, shift   ;[30]
    72e8:	20 93 41 01 	sts	0x0141, r18	; 0x800141 <usbRxToken>
    lds     x2, usbInputBufOffset;[32] swap buffers
    72ec:	10 91 42 01 	lds	r17, 0x0142	; 0x800142 <usbInputBufOffset>
    ldi     cnt, USB_BUFSIZE    ;[34]
    72f0:	3b e0       	ldi	r19, 0x0B	; 11
    sub     cnt, x2             ;[35]
    72f2:	31 1b       	sub	r19, r17
    sts     usbInputBufOffset, cnt;[36] buffers now swapped
    72f4:	30 93 42 01 	sts	0x0142, r19	; 0x800142 <usbInputBufOffset>
    rjmp    sendAckAndReti      ;[38] 40 + 17 = 57 until SOP
    72f8:	1a c0       	rjmp	.+52     	; 0x732e <sendAckAndReti>

000072fa <handleIn>:

handleIn:
;We don't send any data as long as the C code has not processed the current
;input data and potentially updated the output data. That's more efficient
;in terms of code size than clearing the tx buffers when a packet is received.
    lds     x1, usbRxLen        ;[30]
    72fa:	00 91 46 01 	lds	r16, 0x0146	; 0x800146 <usbRxLen>
    cpi     x1, 1               ;[32] negative values are flow control, 0 means "buffer free"
    72fe:	01 30       	cpi	r16, 0x01	; 1
    brge    sendNakAndReti      ;[33] unprocessed input packet?
    7300:	a4 f4       	brge	.+40     	; 0x732a <sendNakAndReti>
    ldi     x1, USBPID_NAK      ;[34] prepare value for usbTxLen
    7302:	0a e5       	ldi	r16, 0x5A	; 90
    brne    sendNakAndReti      ;[36]
#else
    brne    handleIn1           ;[36]
#endif
#endif
    lds     cnt, usbTxLen       ;[37]
    7304:	30 91 01 01 	lds	r19, 0x0101	; 0x800101 <usbTxLen>
    sbrc    cnt, 4              ;[39] all handshake tokens have bit 4 set
    7308:	34 fd       	sbrc	r19, 4
    rjmp    sendCntAndReti      ;[40] 42 + 16 = 58 until SOP
    730a:	12 c0       	rjmp	.+36     	; 0x7330 <sendCntAndReti>
    sts     usbTxLen, x1        ;[41] x1 == USBPID_NAK from above
    730c:	00 93 01 01 	sts	0x0101, r16	; 0x800101 <usbTxLen>
    ldi     YL, lo8(usbTxBuf)   ;[43]
    7310:	c5 e3       	ldi	r28, 0x35	; 53
    ldi     YH, hi8(usbTxBuf)   ;[44]
    7312:	d1 e0       	ldi	r29, 0x01	; 1
    rjmp    usbSendAndReti      ;[45] 57 + 12 = 59 until SOP
    7314:	11 c0       	rjmp	.+34     	; 0x7338 <usbSendAndReti>

00007316 <bitstuffN>:
; Spec allows 7.5 bit times from EOP to SOP for replies
; 7.5 bit times is 100 cycles. This implementation arrives a bit later at se0
; then specified in the include file but there is plenty of time

bitstuffN:
    eor     x1, x4          ;[8]
    7316:	05 27       	eor	r16, r21
    ldi     x2, 0           ;[9]
    7318:	10 e0       	ldi	r17, 0x00	; 0
    nop2                    ;[10]
    731a:	00 c0       	rjmp	.+0      	; 0x731c <bitstuffN+0x6>
    out     USBOUT, x1      ;[12] <-- out
    731c:	08 b9       	out	0x08, r16	; 8
    rjmp    didStuffN       ;[0]
    731e:	19 c0       	rjmp	.+50     	; 0x7352 <didStuffN>

00007320 <bitstuff7>:
    
bitstuff7:
    eor     x1, x4          ;[6]
    7320:	05 27       	eor	r16, r21
    ldi     x2, 0           ;[7] Carry is zero due to brcc
    7322:	10 e0       	ldi	r17, 0x00	; 0
    rol     shift           ;[8] compensate for ror shift at branch destination
    7324:	22 1f       	adc	r18, r18
    nop2                    ;[9]
    7326:	00 c0       	rjmp	.+0      	; 0x7328 <bitstuff7+0x8>
    rjmp    didStuff7       ;[11]
    7328:	1d c0       	rjmp	.+58     	; 0x7364 <didStuff7>

0000732a <sendNakAndReti>:

sendNakAndReti:
    ldi     x3, USBPID_NAK  ;[-18]
    732a:	4a e5       	ldi	r20, 0x5A	; 90
    rjmp    sendX3AndReti   ;[-17]
    732c:	02 c0       	rjmp	.+4      	; 0x7332 <sendX3AndReti>

0000732e <sendAckAndReti>:
sendAckAndReti:
    ldi     cnt, USBPID_ACK ;[-17]
    732e:	32 ed       	ldi	r19, 0xD2	; 210

00007330 <sendCntAndReti>:
sendCntAndReti:
    mov     x3, cnt         ;[-16]
    7330:	43 2f       	mov	r20, r19

00007332 <sendX3AndReti>:
sendX3AndReti:
    ldi     YL, 20          ;[-15] x3==r20 address is 20
    7332:	c4 e1       	ldi	r28, 0x14	; 20
    ldi     YH, 0           ;[-14]
    7334:	d0 e0       	ldi	r29, 0x00	; 0
    ldi     cnt, 2          ;[-13]
    7336:	32 e0       	ldi	r19, 0x02	; 2

00007338 <usbSendAndReti>:
;uses: x1...x4, btcnt, shift, cnt, Y
;Numbers in brackets are time since first bit of sync pattern is sent
;We don't match the transfer rate exactly (don't insert leap cycles every third
;byte) because the spec demands only 1.5% precision anyway.
usbSendAndReti:             ; 12 cycles until SOP
    in      x2, USBDDR      ;[-12]
    7338:	17 b1       	in	r17, 0x07	; 7
    ori     x2, USBMASK     ;[-11]
    733a:	1c 60       	ori	r17, 0x0C	; 12
    sbi     USBOUT, USBMINUS;[-10] prepare idle state; D+ and D- must have been 0 (no pullups)
    733c:	43 9a       	sbi	0x08, 3	; 8
    in      x1, USBOUT      ;[-8] port mirror for tx loop
    733e:	08 b1       	in	r16, 0x08	; 8
    out     USBDDR, x2      ;[-7] <- acquire bus
    7340:	17 b9       	out	0x07, r17	; 7
; need not init x2 (bitstuff history) because sync starts with 0
    ldi     x4, USBMASK     ;[-6] exor mask
    7342:	5c e0       	ldi	r21, 0x0C	; 12
    ldi     shift, 0x80     ;[-5] sync byte is first byte sent
    7344:	20 e8       	ldi	r18, 0x80	; 128

00007346 <txByteLoop>:
txByteLoop:
    ldi     bitcnt, 0x49    ;[-4]        [10] binary 01001001
    7346:	69 e4       	ldi	r22, 0x49	; 73

00007348 <txBitLoop>:
txBitLoop:
    sbrs    shift, 0        ;[-3] [10]   [11]
    7348:	20 ff       	sbrs	r18, 0
    eor     x1, x4          ;[-2] [11]   [12]
    734a:	05 27       	eor	r16, r21
    out     USBOUT, x1      ;[-1] [12]   [13]   <-- out N
    734c:	08 b9       	out	0x08, r16	; 8
    ror     shift           ;[0]  [13]   [14]
    734e:	27 95       	ror	r18
    ror     x2              ;[1]
    7350:	17 95       	ror	r17

00007352 <didStuffN>:
didStuffN:
    nop2                    ;[2]
    7352:	00 c0       	rjmp	.+0      	; 0x7354 <didStuffN+0x2>
    nop                     ;[4]
    7354:	00 00       	nop
    cpi     x2, 0xfc        ;[5]
    7356:	1c 3f       	cpi	r17, 0xFC	; 252
    brcc    bitstuffN       ;[6]
    7358:	f0 f6       	brcc	.-68     	; 0x7316 <bitstuffN>
    lsr     bitcnt          ;[7]
    735a:	66 95       	lsr	r22
    brcc    txBitLoop       ;[8]
    735c:	a8 f7       	brcc	.-22     	; 0x7348 <txBitLoop>
    brne    txBitLoop       ;[9]
    735e:	a1 f7       	brne	.-24     	; 0x7348 <txBitLoop>

    sbrs    shift, 0        ;[10]
    7360:	20 ff       	sbrs	r18, 0
    eor     x1, x4          ;[11]
    7362:	05 27       	eor	r16, r21

00007364 <didStuff7>:
didStuff7:
    out     USBOUT, x1      ;[-1] [13] <-- out 7
    7364:	08 b9       	out	0x08, r16	; 8
    ror     shift           ;[0] [14]
    7366:	27 95       	ror	r18
    ror     x2              ;[1]
    7368:	17 95       	ror	r17
    nop                     ;[2]
    736a:	00 00       	nop
    cpi     x2, 0xfc        ;[3]
    736c:	1c 3f       	cpi	r17, 0xFC	; 252
    brcc    bitstuff7       ;[4]
    736e:	c0 f6       	brcc	.-80     	; 0x7320 <bitstuff7>
    ld      shift, y+       ;[5]
    7370:	29 91       	ld	r18, Y+
    dec     cnt             ;[7]
    7372:	3a 95       	dec	r19
    brne    txByteLoop      ;[8]
    7374:	41 f7       	brne	.-48     	; 0x7346 <txByteLoop>
;make SE0:
    cbr     x1, USBMASK     ;[9] prepare SE0 [spec says EOP may be 25 to 30 cycles]
    7376:	03 7f       	andi	r16, 0xF3	; 243
    lds     x2, usbNewDeviceAddr;[10]
    7378:	10 91 47 01 	lds	r17, 0x0147	; 0x800147 <usbNewDeviceAddr>
    lsl     x2              ;[12] we compare with left shifted address
    737c:	11 0f       	add	r17, r17
    out     USBOUT, x1      ;[13] <-- out SE0 -- from now 2 bits = 22 cycles until bus idle
    737e:	08 b9       	out	0x08, r16	; 8
    subi    YL, 20 + 2      ;[0] Only assign address on data packets, not ACK/NAK in x3
    7380:	c6 51       	subi	r28, 0x16	; 22
    sbci    YH, 0           ;[1]
    7382:	d0 40       	sbci	r29, 0x00	; 0
;2006-03-06: moved transfer of new address to usbDeviceAddr from C-Code to asm:
;set address only after data packet was sent, not after handshake
    breq    skipAddrAssign  ;[2]
    7384:	11 f0       	breq	.+4      	; 0x738a <skipAddrAssign>
    sts     usbDeviceAddr, x2; if not skipped: SE0 is one cycle longer
    7386:	10 93 40 01 	sts	0x0140, r17	; 0x800140 <usbDeviceAddr>

0000738a <skipAddrAssign>:
skipAddrAssign:
;end of usbDeviceAddress transfer
    ldi     x2, 1<<USB_INTR_PENDING_BIT;[4] int0 occurred during TX -- clear pending flag
    738a:	11 e0       	ldi	r17, 0x01	; 1
    USB_STORE_PENDING(x2)   ;[5]
    738c:	1c bb       	out	0x1c, r17	; 28
    ori     x1, USBIDLE     ;[6]
    738e:	08 60       	ori	r16, 0x08	; 8
    in      x2, USBDDR      ;[7]
    7390:	17 b1       	in	r17, 0x07	; 7
    cbr     x2, USBMASK     ;[8] set both pins to input
    7392:	13 7f       	andi	r17, 0xF3	; 243
    mov     x3, x1          ;[9]
    7394:	40 2f       	mov	r20, r16
    cbr     x3, USBMASK     ;[10] configure no pullup on both pins
    7396:	43 7f       	andi	r20, 0xF3	; 243
    ldi     x4, 5           ;[11]
    7398:	55 e0       	ldi	r21, 0x05	; 5

0000739a <se0Delay>:
se0Delay:
    dec     x4              ;[12] [15] [18] [21] [24]
    739a:	5a 95       	dec	r21
    brne    se0Delay        ;[13] [16] [19] [22] [25]
    739c:	f1 f7       	brne	.-4      	; 0x739a <se0Delay>
    out     USBOUT, x1      ;[26] <-- out J (idle) -- end of SE0 (EOP signal)
    739e:	08 b9       	out	0x08, r16	; 8
    out     USBDDR, x2      ;[27] <-- release bus now
    73a0:	17 b9       	out	0x07, r17	; 7
    out     USBOUT, x3      ;[28] <-- ensure no pull-up resistors are active
    73a2:	48 b9       	out	0x08, r20	; 8
    rjmp    doReturn
    73a4:	86 cf       	rjmp	.-244    	; 0x72b2 <doReturn>

000073a6 <give_away>:
	}
}

void give_away(void)
{
	wdt_reset();
    73a6:	a8 95       	wdr
	usbPoll();
    73a8:	67 d0       	rcall	.+206    	; 0x7478 <usbPoll>
	clkPullPwm_bl_togglePin();
    73aa:	06 c2       	rjmp	.+1036   	; 0x77b8 <clkPullPwm_bl_togglePin>

000073ac <main>:
}


int main(void)
{
    73ac:	cf 93       	push	r28
    73ae:	df 93       	push	r29
    73b0:	00 d0       	rcall	.+0      	; 0x73b2 <main+0x6>
    73b2:	00 d0       	rcall	.+0      	; 0x73b4 <main+0x8>
    73b4:	cd b7       	in	r28, 0x3d	; 61
    73b6:	de b7       	in	r29, 0x3e	; 62
	cli();
    73b8:	f8 94       	cli
//	send_error_msg();
//}


static inline void vectortable_to_bootloader(void) {
	cli();
    73ba:	f8 94       	cli
	asm volatile											// set active vector table into the Bootloader section
    73bc:	81 e0       	ldi	r24, 0x01	; 1
    73be:	85 bf       	out	0x35, r24	; 53
    73c0:	82 e0       	ldi	r24, 0x02	; 2
    73c2:	85 bf       	out	0x35, r24	; 53
int main(void)
{
	cli();
	vectortable_to_bootloader();

	PRR    = 0xEF;											// disable all modules within the Power Reduction Register
    73c4:	8f ee       	ldi	r24, 0xEF	; 239
    73c6:	80 93 64 00 	sts	0x0064, r24	; 0x800064 <__TEXT_REGION_LENGTH__+0x7e0064>
	ACSR  |= _BV(ACD);										// switch on Analog Comparator Disable
    73ca:	80 b7       	in	r24, 0x30	; 48
    73cc:	80 68       	ori	r24, 0x80	; 128
    73ce:	80 bf       	out	0x30, r24	; 48
	DIDR1 |= (0b11 << AIN0D);								// disable digital input buffers on AIN0 and AIN1
    73d0:	80 91 7f 00 	lds	r24, 0x007F	; 0x80007f <__TEXT_REGION_LENGTH__+0x7e007f>
    73d4:	83 60       	ori	r24, 0x03	; 3
    73d6:	80 93 7f 00 	sts	0x007F, r24	; 0x80007f <__TEXT_REGION_LENGTH__+0x7e007f>

	// switch off Pull-Up Disable
	MCUCR &= ~(_BV(PUD));
    73da:	85 b7       	in	r24, 0x35	; 53
    73dc:	8f 7e       	andi	r24, 0xEF	; 239
    73de:	85 bf       	out	0x35, r24	; 53
			jump_to_app();									// jump to firmware section
		}

	} else {
		/* INHIBIT jump_to_app() - remove one time token */
		uint16_t clearVal = 0xffff;
    73e0:	0f ef       	ldi	r16, 0xFF	; 255
    73e2:	1f ef       	ldi	r17, 0xFF	; 255
		);
	}
	else
	{
        uint8_t register temp_reg;
		__asm__ __volatile__ (
    73e4:	0f b6       	in	r0, 0x3f	; 63
    73e6:	f8 94       	cli
    73e8:	a8 95       	wdr
    73ea:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__TEXT_REGION_LENGTH__+0x7e0060>
    73ee:	88 61       	ori	r24, 0x18	; 24
    73f0:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__TEXT_REGION_LENGTH__+0x7e0060>
    73f4:	10 92 60 00 	sts	0x0060, r1	; 0x800060 <__TEXT_REGION_LENGTH__+0x7e0060>
    73f8:	0f be       	out	0x3f, r0	; 63
	// switch off Pull-Up Disable
	MCUCR &= ~(_BV(PUD));

	for (;;) {
		wdt_init();
		probe_bl_init();
    73fa:	6b d2       	rcall	.+1238   	; 0x78d2 <probe_bl_init>
}

static inline void app_startup_check()
{
	// look for a BOOT marker in the EEPROM and do not jump to the Firmware when it is found at its place
	uint16_t tokenVal = 0;
    73fc:	1c 82       	std	Y+4, r1	; 0x04
    73fe:	1b 82       	std	Y+3, r1	; 0x03
	memory_bl_readEEpromPage((uint8_t*) &tokenVal, sizeof(tokenVal), BOOT_TOKEN_EE_ADR);
    7400:	4a ef       	ldi	r20, 0xFA	; 250
    7402:	53 e0       	ldi	r21, 0x03	; 3
    7404:	62 e0       	ldi	r22, 0x02	; 2
    7406:	ce 01       	movw	r24, r28
    7408:	03 96       	adiw	r24, 0x03	; 3
    740a:	c4 d2       	rcall	.+1416   	; 0x7994 <memory_bl_readEEpromPage>
	if (tokenVal != BOOT_TOKEN) {
    740c:	8b 81       	ldd	r24, Y+3	; 0x03
    740e:	9c 81       	ldd	r25, Y+4	; 0x04
    7410:	8f 30       	cpi	r24, 0x0F	; 15
    7412:	90 4b       	sbci	r25, 0xB0	; 176
    7414:	d1 f0       	breq	.+52     	; 0x744a <main+0x9e>
		// check for jumper-setting and for a valid jump-table entry
		uint16_t code =  0;
    7416:	1a 82       	std	Y+2, r1	; 0x02
    7418:	19 82       	std	Y+1, r1	; 0x01
		memory_bl_readFlashPage((uint8_t*) &code, sizeof(code), 0x0000);
    741a:	20 e0       	ldi	r18, 0x00	; 0
    741c:	30 e0       	ldi	r19, 0x00	; 0
    741e:	a9 01       	movw	r20, r18
    7420:	62 e0       	ldi	r22, 0x02	; 2
    7422:	ce 01       	movw	r24, r28
    7424:	01 96       	adiw	r24, 0x01	; 1
    7426:	80 d2       	rcall	.+1280   	; 0x7928 <memory_bl_readFlashPage>
		if ((!mainIsJumperBlSet) && (code == 0x940c)) {		// JMP instruction
    7428:	80 91 03 01 	lds	r24, 0x0103	; 0x800103 <mainIsJumperBlSet>
    742c:	81 11       	cpse	r24, r1
    742e:	15 c0       	rjmp	.+42     	; 0x745a <main+0xae>
    7430:	89 81       	ldd	r24, Y+1	; 0x01
    7432:	9a 81       	ldd	r25, Y+2	; 0x02
    7434:	8c 30       	cpi	r24, 0x0C	; 12
    7436:	94 49       	sbci	r25, 0x94	; 148
    7438:	81 f4       	brne	.+32     	; 0x745a <main+0xae>
			probe_bl_close();
    743a:	42 d2       	rcall	.+1156   	; 0x78c0 <probe_bl_close>
			cli();
    743c:	f8 94       	cli
			jump_to_app();									// jump to firmware section
    743e:	e0 91 05 01 	lds	r30, 0x0105	; 0x800105 <jump_to_app>
    7442:	f0 91 06 01 	lds	r31, 0x0106	; 0x800106 <jump_to_app+0x1>
    7446:	09 95       	icall
    7448:	08 c0       	rjmp	.+16     	; 0x745a <main+0xae>
		}

	} else {
		/* INHIBIT jump_to_app() - remove one time token */
		uint16_t clearVal = 0xffff;
    744a:	1a 83       	std	Y+2, r17	; 0x02
    744c:	09 83       	std	Y+1, r16	; 0x01
		memory_bl_writeEEpromPage((uint8_t*) &clearVal, sizeof(clearVal), BOOT_TOKEN_EE_ADR);
    744e:	4a ef       	ldi	r20, 0xFA	; 250
    7450:	53 e0       	ldi	r21, 0x03	; 3
    7452:	62 e0       	ldi	r22, 0x02	; 2
    7454:	ce 01       	movw	r24, r28
    7456:	01 96       	adiw	r24, 0x01	; 1
    7458:	9c d3       	rcall	.+1848   	; 0x7b92 <memory_bl_writeEEpromPage>
	for (;;) {
		wdt_init();
		probe_bl_init();
		app_startup_check();								// try to jump to the application FIRMWARE, else return

		clkPullPwm_bl_init();
    745a:	92 d1       	rcall	.+804    	; 0x7780 <clkPullPwm_bl_init>
		usb_bl_init();										// starts at 67 ms after power-up, ends at 316 ms after power-up
    745c:	cf d3       	rcall	.+1950   	; 0x7bfc <usb_bl_init>

		mainStopAvr = false;
    745e:	10 92 02 01 	sts	0x0102, r1	; 0x800102 <__data_end>
		sei();												// ENABLE interrupt
    7462:	78 94       	sei
		while(!mainStopAvr) {								// falls out when DISCONNECT message is received
    7464:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__data_end>
    7468:	81 11       	cpse	r24, r1
    746a:	02 c0       	rjmp	.+4      	; 0x7470 <main+0xc4>
			give_away();
    746c:	9c df       	rcall	.-200    	; 0x73a6 <give_away>
    746e:	fa cf       	rjmp	.-12     	; 0x7464 <main+0xb8>
		}
		cli();												// DISABLE interrupt
    7470:	f8 94       	cli

		usb_bl_close();
    7472:	d5 d3       	rcall	.+1962   	; 0x7c1e <usb_bl_close>
		clkPullPwm_bl_close();
    7474:	95 d1       	rcall	.+810    	; 0x77a0 <clkPullPwm_bl_close>
		//	probe_bl_close();
		//	wdt_close();
	}
    7476:	b6 cf       	rjmp	.-148    	; 0x73e4 <main+0x38>

00007478 <usbPoll>:
}

/* ------------------------------------------------------------------------- */

USB_PUBLIC void usbPoll(void)
{
    7478:	cf 93       	push	r28
    747a:	df 93       	push	r29
schar   len;
uchar   i;

    len = usbRxLen - 3;
    747c:	60 91 46 01 	lds	r22, 0x0146	; 0x800146 <usbRxLen>
    7480:	63 50       	subi	r22, 0x03	; 3
    if(len >= 0){
    7482:	67 fd       	sbrc	r22, 7
    7484:	d1 c0       	rjmp	.+418    	; 0x7628 <usbPoll+0x1b0>
 * need data integrity checks with this driver, check the CRC in your app
 * code and report errors back to the host. Since the ACK was already sent,
 * retries must be handled on application level.
 * unsigned crc = usbCrc16(buffer + 1, usbRxLen - 3);
 */
        usbProcessRx(usbRxBuf + USB_BUFSIZE + 1 - usbInputBufOffset, len);
    7486:	80 91 42 01 	lds	r24, 0x0142	; 0x800142 <usbInputBufOffset>
    748a:	cc e0       	ldi	r28, 0x0C	; 12
    748c:	d0 e0       	ldi	r29, 0x00	; 0
    748e:	c8 1b       	sub	r28, r24
    7490:	d1 09       	sbc	r29, r1
    7492:	c6 5b       	subi	r28, 0xB6	; 182
    7494:	de 4f       	sbci	r29, 0xFE	; 254
    if(usbRxToken < 0x10){  /* OUT to endpoint != 0: endpoint number in usbRxToken */
        usbFunctionWriteOut(data, len);
        return;
    }
#endif
    if(usbRxToken == (uchar)USBPID_SETUP){
    7496:	80 91 41 01 	lds	r24, 0x0141	; 0x800141 <usbRxToken>
    749a:	8d 32       	cpi	r24, 0x2D	; 45
    749c:	09 f0       	breq	.+2      	; 0x74a0 <usbPoll+0x28>
    749e:	b3 c0       	rjmp	.+358    	; 0x7606 <usbPoll+0x18e>
        if(len != 8)    /* Setup size must be always 8 bytes. Ignore otherwise. */
    74a0:	68 30       	cpi	r22, 0x08	; 8
    74a2:	09 f0       	breq	.+2      	; 0x74a6 <usbPoll+0x2e>
    74a4:	bf c0       	rjmp	.+382    	; 0x7624 <usbPoll+0x1ac>
            return;
        usbMsgLen_t replyLen;
        usbTxBuf[0] = USBPID_DATA0;         /* initialize data toggling */
    74a6:	83 ec       	ldi	r24, 0xC3	; 195
    74a8:	80 93 35 01 	sts	0x0135, r24	; 0x800135 <usbTxBuf>
        usbTxLen = USBPID_NAK;              /* abort pending transmit */
    74ac:	8a e5       	ldi	r24, 0x5A	; 90
    74ae:	80 93 01 01 	sts	0x0101, r24	; 0x800101 <usbTxLen>
        usbMsgFlags = 0;
    74b2:	10 92 0c 01 	sts	0x010C, r1	; 0x80010c <usbMsgFlags>
        uchar type = rq->bmRequestType & USBRQ_TYPE_MASK;
    74b6:	28 81       	ld	r18, Y
    74b8:	82 2f       	mov	r24, r18
    74ba:	80 76       	andi	r24, 0x60	; 96
        if(type != USBRQ_TYPE_STANDARD){    /* standard requests are handled by driver */
    74bc:	39 f0       	breq	.+14     	; 0x74cc <usbPoll+0x54>
            replyLen = usbFunctionSetup(data);
    74be:	ce 01       	movw	r24, r28
    74c0:	b2 d3       	rcall	.+1892   	; 0x7c26 <usbFunctionSetup>
    74c2:	98 2f       	mov	r25, r24
        }else{
            replyLen = usbDriverSetup(rq);
        }
#if USB_CFG_IMPLEMENT_FN_READ || USB_CFG_IMPLEMENT_FN_WRITE
        if(replyLen == USB_NO_MSG){         /* use user-supplied read/write function */
    74c4:	8f 3f       	cpi	r24, 0xFF	; 255
    74c6:	09 f4       	brne	.+2      	; 0x74ca <usbPoll+0x52>
    74c8:	8d c0       	rjmp	.+282    	; 0x75e4 <usbPoll+0x16c>
    74ca:	93 c0       	rjmp	.+294    	; 0x75f2 <usbPoll+0x17a>
 */
static inline usbMsgLen_t usbDriverSetup(usbRequest_t *rq)
{
usbMsgLen_t len = 0;
uchar   *dataPtr = usbTxBuf + 9;    /* there are 2 bytes free space at the end of the buffer */
uchar   value = rq->wValue.bytes[0];
    74cc:	9a 81       	ldd	r25, Y+2	; 0x02
#if USB_CFG_IMPLEMENT_HALT
uchar   index = rq->wIndex.bytes[0];
    74ce:	3c 81       	ldd	r19, Y+4	; 0x04
#endif

    dataPtr[0] = 0; /* default reply common to USBRQ_GET_STATUS and USBRQ_GET_INTERFACE */
    74d0:	10 92 3e 01 	sts	0x013E, r1	; 0x80013e <usbTxBuf+0x9>
    SWITCH_START(rq->bRequest)
    74d4:	89 81       	ldd	r24, Y+1	; 0x01
    SWITCH_CASE(USBRQ_GET_STATUS)           /* 0 */
    74d6:	81 11       	cpse	r24, r1
    74d8:	13 c0       	rjmp	.+38     	; 0x7500 <usbPoll+0x88>
        uchar recipient = rq->bmRequestType & USBRQ_RCPT_MASK;  /* assign arith ops to variables to enforce byte size */
    74da:	2f 71       	andi	r18, 0x1F	; 31
        if(USB_CFG_IS_SELF_POWERED && recipient == USBRQ_RCPT_DEVICE)
            dataPtr[0] =  USB_CFG_IS_SELF_POWERED;
#if USB_CFG_IMPLEMENT_HALT
        if(recipient == USBRQ_RCPT_ENDPOINT && index == 0x81)   /* request status for endpoint 1 */
    74dc:	22 30       	cpi	r18, 0x02	; 2
    74de:	51 f4       	brne	.+20     	; 0x74f4 <usbPoll+0x7c>
    74e0:	31 38       	cpi	r19, 0x81	; 129
    74e2:	41 f4       	brne	.+16     	; 0x74f4 <usbPoll+0x7c>
            dataPtr[0] = usbTxLen1 == USBPID_STALL;
    74e4:	90 91 0d 01 	lds	r25, 0x010D	; 0x80010d <usbTxStatus1>
    74e8:	81 e0       	ldi	r24, 0x01	; 1
    74ea:	9e 31       	cpi	r25, 0x1E	; 30
    74ec:	09 f0       	breq	.+2      	; 0x74f0 <usbPoll+0x78>
    74ee:	80 e0       	ldi	r24, 0x00	; 0
    74f0:	80 93 3e 01 	sts	0x013E, r24	; 0x80013e <usbTxBuf+0x9>
#endif
        dataPtr[1] = 0;
    74f4:	10 92 3f 01 	sts	0x013F, r1	; 0x80013f <usbTxBuf+0xa>
 * standard requests instead of class and custom requests.
 */
static inline usbMsgLen_t usbDriverSetup(usbRequest_t *rq)
{
usbMsgLen_t len = 0;
uchar   *dataPtr = usbTxBuf + 9;    /* there are 2 bytes free space at the end of the buffer */
    74f8:	2e e3       	ldi	r18, 0x3E	; 62
    74fa:	31 e0       	ldi	r19, 0x01	; 1
#if USB_CFG_IMPLEMENT_HALT
        if(recipient == USBRQ_RCPT_ENDPOINT && index == 0x81)   /* request status for endpoint 1 */
            dataPtr[0] = usbTxLen1 == USBPID_STALL;
#endif
        dataPtr[1] = 0;
        len = 2;
    74fc:	92 e0       	ldi	r25, 0x02	; 2
    74fe:	6d c0       	rjmp	.+218    	; 0x75da <usbPoll+0x162>
#if USB_CFG_IMPLEMENT_HALT
    SWITCH_CASE2(USBRQ_CLEAR_FEATURE, USBRQ_SET_FEATURE)    /* 1, 3 */
    7500:	28 2f       	mov	r18, r24
    7502:	2d 7f       	andi	r18, 0xFD	; 253
    7504:	21 30       	cpi	r18, 0x01	; 1
    7506:	69 f4       	brne	.+26     	; 0x7522 <usbPoll+0xaa>
        if(value == 0 && index == 0x81){    /* feature 0 == HALT for endpoint == 1 */
    7508:	91 11       	cpse	r25, r1
    750a:	60 c0       	rjmp	.+192    	; 0x75cc <usbPoll+0x154>
    750c:	31 38       	cpi	r19, 0x81	; 129
    750e:	09 f0       	breq	.+2      	; 0x7512 <usbPoll+0x9a>
    7510:	5d c0       	rjmp	.+186    	; 0x75cc <usbPoll+0x154>
            usbTxLen1 = rq->bRequest == USBRQ_CLEAR_FEATURE ? USBPID_NAK : USBPID_STALL;
    7512:	81 30       	cpi	r24, 0x01	; 1
    7514:	11 f0       	breq	.+4      	; 0x751a <usbPoll+0xa2>
    7516:	8e e1       	ldi	r24, 0x1E	; 30
    7518:	01 c0       	rjmp	.+2      	; 0x751c <usbPoll+0xa4>
    751a:	8a e5       	ldi	r24, 0x5A	; 90
    751c:	80 93 0d 01 	sts	0x010D, r24	; 0x80010d <usbTxStatus1>
    7520:	55 c0       	rjmp	.+170    	; 0x75cc <usbPoll+0x154>
            usbResetDataToggling();
        }
#endif
    SWITCH_CASE(USBRQ_SET_ADDRESS)          /* 5 */
    7522:	85 30       	cpi	r24, 0x05	; 5
    7524:	19 f4       	brne	.+6      	; 0x752c <usbPoll+0xb4>
        usbNewDeviceAddr = value;
    7526:	90 93 47 01 	sts	0x0147, r25	; 0x800147 <usbNewDeviceAddr>
    752a:	50 c0       	rjmp	.+160    	; 0x75cc <usbPoll+0x154>
        USB_SET_ADDRESS_HOOK();
    SWITCH_CASE(USBRQ_GET_DESCRIPTOR)       /* 6 */
    752c:	86 30       	cpi	r24, 0x06	; 6
    752e:	09 f0       	breq	.+2      	; 0x7532 <usbPoll+0xba>
    7530:	3f c0       	rjmp	.+126    	; 0x75b0 <usbPoll+0x138>
    7532:	8b 81       	ldd	r24, Y+3	; 0x03
{
usbMsgLen_t len = 0;
uchar       flags = USB_FLG_MSGPTR_IS_ROM;

    SWITCH_START(rq->wValue.bytes[1])
    SWITCH_CASE(USBDESCR_DEVICE)    /* 1 */
    7534:	81 30       	cpi	r24, 0x01	; 1
    7536:	19 f4       	brne	.+6      	; 0x753e <usbPoll+0xc6>
        GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_DEVICE, usbDescriptorDevice)
    7538:	8a e7       	ldi	r24, 0x7A	; 122
    753a:	90 e7       	ldi	r25, 0x70	; 112
    753c:	04 c0       	rjmp	.+8      	; 0x7546 <usbPoll+0xce>
    SWITCH_CASE(USBDESCR_CONFIG)    /* 2 */
    753e:	82 30       	cpi	r24, 0x02	; 2
    7540:	41 f4       	brne	.+16     	; 0x7552 <usbPoll+0xda>
        GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_CONFIGURATION, usbDescriptorConfiguration)
    7542:	88 e6       	ldi	r24, 0x68	; 104
    7544:	90 e7       	ldi	r25, 0x70	; 112
    7546:	90 93 45 01 	sts	0x0145, r25	; 0x800145 <usbMsgPtr+0x1>
    754a:	80 93 44 01 	sts	0x0144, r24	; 0x800144 <usbMsgPtr>
    754e:	92 e1       	ldi	r25, 0x12	; 18
    7550:	2b c0       	rjmp	.+86     	; 0x75a8 <usbPoll+0x130>
    SWITCH_CASE(USBDESCR_STRING)    /* 3 */
    7552:	83 30       	cpi	r24, 0x03	; 3
    7554:	41 f5       	brne	.+80     	; 0x75a6 <usbPoll+0x12e>
        if(USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_RAM)
            flags = 0;
        len = usbFunctionDescriptor(rq);
#else   /* USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_DYNAMIC */
        SWITCH_START(rq->wValue.bytes[0])
        SWITCH_CASE(0)
    7556:	91 11       	cpse	r25, r1
    7558:	08 c0       	rjmp	.+16     	; 0x756a <usbPoll+0xf2>
            GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_0, usbDescriptorString0)
    755a:	82 ef       	ldi	r24, 0xF2	; 242
    755c:	90 e7       	ldi	r25, 0x70	; 112
    755e:	90 93 45 01 	sts	0x0145, r25	; 0x800145 <usbMsgPtr+0x1>
    7562:	80 93 44 01 	sts	0x0144, r24	; 0x800144 <usbMsgPtr>
    7566:	94 e0       	ldi	r25, 0x04	; 4
    7568:	1f c0       	rjmp	.+62     	; 0x75a8 <usbPoll+0x130>
        SWITCH_CASE(1)
    756a:	91 30       	cpi	r25, 0x01	; 1
    756c:	41 f4       	brne	.+16     	; 0x757e <usbPoll+0x106>
            GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_VENDOR, usbDescriptorStringVendor)
    756e:	84 ee       	ldi	r24, 0xE4	; 228
    7570:	90 e7       	ldi	r25, 0x70	; 112
    7572:	90 93 45 01 	sts	0x0145, r25	; 0x800145 <usbMsgPtr+0x1>
    7576:	80 93 44 01 	sts	0x0144, r24	; 0x800144 <usbMsgPtr>
    757a:	9e e0       	ldi	r25, 0x0E	; 14
    757c:	15 c0       	rjmp	.+42     	; 0x75a8 <usbPoll+0x130>
        SWITCH_CASE(2)
    757e:	92 30       	cpi	r25, 0x02	; 2
    7580:	41 f4       	brne	.+16     	; 0x7592 <usbPoll+0x11a>
            GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_PRODUCT, usbDescriptorStringDevice)
    7582:	8c e9       	ldi	r24, 0x9C	; 156
    7584:	90 e7       	ldi	r25, 0x70	; 112
    7586:	90 93 45 01 	sts	0x0145, r25	; 0x800145 <usbMsgPtr+0x1>
    758a:	80 93 44 01 	sts	0x0144, r24	; 0x800144 <usbMsgPtr>
    758e:	98 e4       	ldi	r25, 0x48	; 72
    7590:	0b c0       	rjmp	.+22     	; 0x75a8 <usbPoll+0x130>
        SWITCH_CASE(3)
    7592:	93 30       	cpi	r25, 0x03	; 3
    7594:	41 f4       	brne	.+16     	; 0x75a6 <usbPoll+0x12e>
            GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER, usbDescriptorStringSerialNumber)
    7596:	8c e8       	ldi	r24, 0x8C	; 140
    7598:	90 e7       	ldi	r25, 0x70	; 112
    759a:	90 93 45 01 	sts	0x0145, r25	; 0x800145 <usbMsgPtr+0x1>
    759e:	80 93 44 01 	sts	0x0144, r24	; 0x800144 <usbMsgPtr>
    75a2:	90 e1       	ldi	r25, 0x10	; 16
    75a4:	01 c0       	rjmp	.+2      	; 0x75a8 <usbPoll+0x130>
/* usbDriverDescriptor() is similar to usbFunctionDescriptor(), but used
 * internally for all types of descriptors.
 */
static inline usbMsgLen_t usbDriverDescriptor(usbRequest_t *rq)
{
usbMsgLen_t len = 0;
    75a6:	90 e0       	ldi	r25, 0x00	; 0
    SWITCH_DEFAULT
        if(USB_CFG_DESCR_PROPS_UNKNOWN & USB_PROP_IS_DYNAMIC){
            len = usbFunctionDescriptor(rq);
        }
    SWITCH_END
    usbMsgFlags = flags;
    75a8:	80 e4       	ldi	r24, 0x40	; 64
    75aa:	80 93 0c 01 	sts	0x010C, r24	; 0x80010c <usbMsgFlags>
    75ae:	21 c0       	rjmp	.+66     	; 0x75f2 <usbPoll+0x17a>
        usbNewDeviceAddr = value;
        USB_SET_ADDRESS_HOOK();
    SWITCH_CASE(USBRQ_GET_DESCRIPTOR)       /* 6 */
        len = usbDriverDescriptor(rq);
        goto skipMsgPtrAssignment;
    SWITCH_CASE(USBRQ_GET_CONFIGURATION)    /* 8 */
    75b0:	88 30       	cpi	r24, 0x08	; 8
    75b2:	81 f0       	breq	.+32     	; 0x75d4 <usbPoll+0x15c>
        dataPtr = &usbConfiguration;  /* send current configuration value */
        len = 1;
    SWITCH_CASE(USBRQ_SET_CONFIGURATION)    /* 9 */
    75b4:	89 30       	cpi	r24, 0x09	; 9
    75b6:	19 f4       	brne	.+6      	; 0x75be <usbPoll+0x146>
        usbConfiguration = value;
    75b8:	90 93 49 01 	sts	0x0149, r25	; 0x800149 <usbConfiguration>
    75bc:	07 c0       	rjmp	.+14     	; 0x75cc <usbPoll+0x154>
        usbResetStall();
    SWITCH_CASE(USBRQ_GET_INTERFACE)        /* 10 */
    75be:	91 e0       	ldi	r25, 0x01	; 1
    75c0:	8a 30       	cpi	r24, 0x0A	; 10
    75c2:	09 f0       	breq	.+2      	; 0x75c6 <usbPoll+0x14e>
    75c4:	90 e0       	ldi	r25, 0x00	; 0
 * standard requests instead of class and custom requests.
 */
static inline usbMsgLen_t usbDriverSetup(usbRequest_t *rq)
{
usbMsgLen_t len = 0;
uchar   *dataPtr = usbTxBuf + 9;    /* there are 2 bytes free space at the end of the buffer */
    75c6:	2e e3       	ldi	r18, 0x3E	; 62
    75c8:	31 e0       	ldi	r19, 0x01	; 1
    75ca:	07 c0       	rjmp	.+14     	; 0x75da <usbPoll+0x162>
    75cc:	2e e3       	ldi	r18, 0x3E	; 62
    75ce:	31 e0       	ldi	r19, 0x01	; 1
/* usbDriverSetup() is similar to usbFunctionSetup(), but it's used for
 * standard requests instead of class and custom requests.
 */
static inline usbMsgLen_t usbDriverSetup(usbRequest_t *rq)
{
usbMsgLen_t len = 0;
    75d0:	90 e0       	ldi	r25, 0x00	; 0
    75d2:	03 c0       	rjmp	.+6      	; 0x75da <usbPoll+0x162>
        USB_SET_ADDRESS_HOOK();
    SWITCH_CASE(USBRQ_GET_DESCRIPTOR)       /* 6 */
        len = usbDriverDescriptor(rq);
        goto skipMsgPtrAssignment;
    SWITCH_CASE(USBRQ_GET_CONFIGURATION)    /* 8 */
        dataPtr = &usbConfiguration;  /* send current configuration value */
    75d4:	29 e4       	ldi	r18, 0x49	; 73
    75d6:	31 e0       	ldi	r19, 0x01	; 1
        len = 1;
    75d8:	91 e0       	ldi	r25, 0x01	; 1
        usbResetStall();
#endif
    SWITCH_DEFAULT                          /* 7=SET_DESCRIPTOR, 12=SYNC_FRAME */
        /* Should we add an optional hook here? */
    SWITCH_END
    usbMsgPtr = (usbMsgPtr_t)dataPtr;
    75da:	30 93 45 01 	sts	0x0145, r19	; 0x800145 <usbMsgPtr+0x1>
    75de:	20 93 44 01 	sts	0x0144, r18	; 0x800144 <usbMsgPtr>
    75e2:	07 c0       	rjmp	.+14     	; 0x75f2 <usbPoll+0x17a>
            replyLen = usbDriverSetup(rq);
        }
#if USB_CFG_IMPLEMENT_FN_READ || USB_CFG_IMPLEMENT_FN_WRITE
        if(replyLen == USB_NO_MSG){         /* use user-supplied read/write function */
            /* do some conditioning on replyLen, but on IN transfers only */
            if((rq->bmRequestType & USBRQ_DIR_MASK) != USBRQ_DIR_HOST_TO_DEVICE){
    75e4:	88 81       	ld	r24, Y
    75e6:	87 fd       	sbrc	r24, 7
                if(sizeof(replyLen) < sizeof(rq->wLength.word)){ /* help compiler with optimizing */
                    replyLen = rq->wLength.bytes[0];
    75e8:	9e 81       	ldd	r25, Y+6	; 0x06
                }else{
                    replyLen = rq->wLength.word;
                }
            }
            usbMsgFlags = USB_FLG_USE_USER_RW;
    75ea:	80 e8       	ldi	r24, 0x80	; 128
    75ec:	80 93 0c 01 	sts	0x010C, r24	; 0x80010c <usbMsgFlags>
    75f0:	07 c0       	rjmp	.+14     	; 0x7600 <usbPoll+0x188>
        }else   /* The 'else' prevents that we limit a replyLen of USB_NO_MSG to the maximum transfer len. */
#endif
        if(sizeof(replyLen) < sizeof(rq->wLength.word)){ /* help compiler with optimizing */
            if(!rq->wLength.bytes[1] && replyLen > rq->wLength.bytes[0])    /* limit length to max */
    75f2:	8f 81       	ldd	r24, Y+7	; 0x07
    75f4:	81 11       	cpse	r24, r1
    75f6:	04 c0       	rjmp	.+8      	; 0x7600 <usbPoll+0x188>
    75f8:	8e 81       	ldd	r24, Y+6	; 0x06
    75fa:	89 17       	cp	r24, r25
    75fc:	08 f4       	brcc	.+2      	; 0x7600 <usbPoll+0x188>
    75fe:	98 2f       	mov	r25, r24
                replyLen = rq->wLength.bytes[0];
        }else{
            if(replyLen > rq->wLength.word)     /* limit length to max */
                replyLen = rq->wLength.word;
        }
        usbMsgLen = replyLen;
    7600:	90 93 00 01 	sts	0x0100, r25	; 0x800100 <__data_start>
    7604:	0f c0       	rjmp	.+30     	; 0x7624 <usbPoll+0x1ac>
    }else{  /* usbRxToken must be USBPID_OUT, which means data phase of setup (control-out) */
#if USB_CFG_IMPLEMENT_FN_WRITE
        if(usbMsgFlags & USB_FLG_USE_USER_RW){
    7606:	80 91 0c 01 	lds	r24, 0x010C	; 0x80010c <usbMsgFlags>
    760a:	87 ff       	sbrs	r24, 7
    760c:	0b c0       	rjmp	.+22     	; 0x7624 <usbPoll+0x1ac>
            uchar rval = usbFunctionWrite(data, len);
    760e:	ce 01       	movw	r24, r28
    7610:	9e d4       	rcall	.+2364   	; 0x7f4e <usbFunctionWrite>
            if(rval == 0xff){   /* an error occurred */
    7612:	8f 3f       	cpi	r24, 0xFF	; 255
    7614:	21 f4       	brne	.+8      	; 0x761e <usbPoll+0x1a6>
                usbTxLen = USBPID_STALL;
    7616:	8e e1       	ldi	r24, 0x1E	; 30
    7618:	80 93 01 01 	sts	0x0101, r24	; 0x800101 <usbTxLen>
    761c:	03 c0       	rjmp	.+6      	; 0x7624 <usbPoll+0x1ac>
            }else if(rval != 0){    /* This was the final package */
    761e:	81 11       	cpse	r24, r1
                usbMsgLen = 0;  /* answer with a zero-sized data packet */
    7620:	10 92 00 01 	sts	0x0100, r1	; 0x800100 <__data_start>
        usbProcessRx(usbRxBuf + USB_BUFSIZE + 1 - usbInputBufOffset, len);
#if USB_CFG_HAVE_FLOWCONTROL
        if(usbRxLen > 0)    /* only mark as available if not inactivated */
            usbRxLen = 0;
#else
        usbRxLen = 0;       /* mark rx buffer as available */
    7624:	10 92 46 01 	sts	0x0146, r1	; 0x800146 <usbRxLen>
#endif
    }
    if(usbTxLen & 0x10){    /* transmit system idle */
    7628:	80 91 01 01 	lds	r24, 0x0101	; 0x800101 <usbTxLen>
    762c:	84 ff       	sbrs	r24, 4
    762e:	4f c0       	rjmp	.+158    	; 0x76ce <usbPoll+0x256>
        if(usbMsgLen != USB_NO_MSG){    /* transmit data pending? */
    7630:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
    7634:	8f 3f       	cpi	r24, 0xFF	; 255
    7636:	09 f4       	brne	.+2      	; 0x763a <usbPoll+0x1c2>
    7638:	4a c0       	rjmp	.+148    	; 0x76ce <usbPoll+0x256>
    763a:	c8 2f       	mov	r28, r24
    763c:	89 30       	cpi	r24, 0x09	; 9
    763e:	08 f0       	brcs	.+2      	; 0x7642 <usbPoll+0x1ca>
    7640:	c8 e0       	ldi	r28, 0x08	; 8
uchar       len;

    wantLen = usbMsgLen;
    if(wantLen > 8)
        wantLen = 8;
    usbMsgLen -= wantLen;
    7642:	8c 1b       	sub	r24, r28
    7644:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
    usbTxBuf[0] ^= USBPID_DATA0 ^ USBPID_DATA1; /* DATA toggling */
    7648:	90 91 35 01 	lds	r25, 0x0135	; 0x800135 <usbTxBuf>
    764c:	88 e8       	ldi	r24, 0x88	; 136
    764e:	89 27       	eor	r24, r25
    7650:	80 93 35 01 	sts	0x0135, r24	; 0x800135 <usbTxBuf>
/* This function is similar to usbFunctionRead(), but it's also called for
 * data handled automatically by the driver (e.g. descriptor reads).
 */
static uchar usbDeviceRead(uchar *data, uchar len)
{
    if(len > 0){    /* don't bother app with 0 sized reads */
    7654:	cc 23       	and	r28, r28
    7656:	51 f1       	breq	.+84     	; 0x76ac <usbPoll+0x234>
#if USB_CFG_IMPLEMENT_FN_READ
        if(usbMsgFlags & USB_FLG_USE_USER_RW){
    7658:	30 91 0c 01 	lds	r19, 0x010C	; 0x80010c <usbMsgFlags>
    765c:	37 ff       	sbrs	r19, 7
    765e:	08 c0       	rjmp	.+16     	; 0x7670 <usbPoll+0x1f8>
            len = usbFunctionRead(data, len);
    7660:	6c 2f       	mov	r22, r28
    7662:	86 e3       	ldi	r24, 0x36	; 54
    7664:	91 e0       	ldi	r25, 0x01	; 1
    7666:	3c d4       	rcall	.+2168   	; 0x7ee0 <usbFunctionRead>
    7668:	c8 2f       	mov	r28, r24
    if(wantLen > 8)
        wantLen = 8;
    usbMsgLen -= wantLen;
    usbTxBuf[0] ^= USBPID_DATA0 ^ USBPID_DATA1; /* DATA toggling */
    len = usbDeviceRead(usbTxBuf + 1, wantLen);
    if(len <= 8){           /* valid data packet */
    766a:	89 30       	cpi	r24, 0x09	; 9
    766c:	50 f5       	brcc	.+84     	; 0x76c2 <usbPoll+0x24a>
    766e:	1e c0       	rjmp	.+60     	; 0x76ac <usbPoll+0x234>
            len = usbFunctionRead(data, len);
        }else
#endif
        {
            uchar i = len;
            usbMsgPtr_t r = usbMsgPtr;
    7670:	80 91 44 01 	lds	r24, 0x0144	; 0x800144 <usbMsgPtr>
    7674:	90 91 45 01 	lds	r25, 0x0145	; 0x800145 <usbMsgPtr+0x1>
    7678:	2c 2f       	mov	r18, r28
    767a:	28 0f       	add	r18, r24
    767c:	a6 e3       	ldi	r26, 0x36	; 54
    767e:	b1 e0       	ldi	r27, 0x01	; 1
            if(usbMsgFlags & USB_FLG_MSGPTR_IS_ROM){    /* ROM data */
    7680:	fc 01       	movw	r30, r24
    7682:	36 ff       	sbrs	r19, 6
    7684:	06 c0       	rjmp	.+12     	; 0x7692 <usbPoll+0x21a>
                do{
                    uchar c = USB_READ_FLASH(r);    /* assign to char size variable to enforce byte ops */
    7686:	34 91       	lpm	r19, Z
                    *data++ = c;
    7688:	3d 93       	st	X+, r19
                    r++;
    768a:	31 96       	adiw	r30, 0x01	; 1
                }while(--i);
    768c:	2e 13       	cpse	r18, r30
    768e:	fb cf       	rjmp	.-10     	; 0x7686 <usbPoll+0x20e>
    7690:	04 c0       	rjmp	.+8      	; 0x769a <usbPoll+0x222>
            }else{  /* RAM data */
                do{
                    *data++ = *((uchar *)r);
    7692:	31 91       	ld	r19, Z+
    7694:	3d 93       	st	X+, r19
                    r++;
                }while(--i);
    7696:	2e 13       	cpse	r18, r30
    7698:	fc cf       	rjmp	.-8      	; 0x7692 <usbPoll+0x21a>
    769a:	01 96       	adiw	r24, 0x01	; 1
    769c:	2f ef       	ldi	r18, 0xFF	; 255
    769e:	2c 0f       	add	r18, r28
    76a0:	82 0f       	add	r24, r18
    76a2:	91 1d       	adc	r25, r1
            }
            usbMsgPtr = r;
    76a4:	90 93 45 01 	sts	0x0145, r25	; 0x800145 <usbMsgPtr+0x1>
    76a8:	80 93 44 01 	sts	0x0144, r24	; 0x800144 <usbMsgPtr>
        wantLen = 8;
    usbMsgLen -= wantLen;
    usbTxBuf[0] ^= USBPID_DATA0 ^ USBPID_DATA1; /* DATA toggling */
    len = usbDeviceRead(usbTxBuf + 1, wantLen);
    if(len <= 8){           /* valid data packet */
        usbCrc16Append(&usbTxBuf[1], len);
    76ac:	6c 2f       	mov	r22, r28
    76ae:	86 e3       	ldi	r24, 0x36	; 54
    76b0:	91 e0       	ldi	r25, 0x01	; 1
    76b2:	62 dd       	rcall	.-1340   	; 0x7178 <usbCrc16Append>
        len += 4;           /* length including sync byte */
    76b4:	cc 5f       	subi	r28, 0xFC	; 252
        if(len < 12)        /* a partial package identifies end of message */
    76b6:	cc 30       	cpi	r28, 0x0C	; 12
    76b8:	41 f0       	breq	.+16     	; 0x76ca <usbPoll+0x252>
            usbMsgLen = USB_NO_MSG;
    76ba:	8f ef       	ldi	r24, 0xFF	; 255
    76bc:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
    76c0:	04 c0       	rjmp	.+8      	; 0x76ca <usbPoll+0x252>
    }else{
        len = USBPID_STALL;   /* stall the endpoint */
        usbMsgLen = USB_NO_MSG;
    76c2:	8f ef       	ldi	r24, 0xFF	; 255
    76c4:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
        usbCrc16Append(&usbTxBuf[1], len);
        len += 4;           /* length including sync byte */
        if(len < 12)        /* a partial package identifies end of message */
            usbMsgLen = USB_NO_MSG;
    }else{
        len = USBPID_STALL;   /* stall the endpoint */
    76c8:	ce e1       	ldi	r28, 0x1E	; 30
        usbMsgLen = USB_NO_MSG;
    }
    usbTxLen = len;
    76ca:	c0 93 01 01 	sts	0x0101, r28	; 0x800101 <usbTxLen>
        usbCrc16Append(&usbTxBuf[1], len);
        len += 4;           /* length including sync byte */
        if(len < 12)        /* a partial package identifies end of message */
            usbMsgLen = USB_NO_MSG;
    }else{
        len = USBPID_STALL;   /* stall the endpoint */
    76ce:	84 e1       	ldi	r24, 0x14	; 20
        if(usbMsgLen != USB_NO_MSG){    /* transmit data pending? */
            usbBuildTxBlock();
        }
    }
    for(i = 20; i > 0; i--){
        uchar usbLineStatus = USBIN & USBMASK;
    76d0:	96 b1       	in	r25, 0x06	; 6
    76d2:	9c 70       	andi	r25, 0x0C	; 12
        if(usbLineStatus != 0)  /* SE0 has ended */
    76d4:	31 f4       	brne	.+12     	; 0x76e2 <usbPoll+0x26a>
    76d6:	81 50       	subi	r24, 0x01	; 1
    if(usbTxLen & 0x10){    /* transmit system idle */
        if(usbMsgLen != USB_NO_MSG){    /* transmit data pending? */
            usbBuildTxBlock();
        }
    }
    for(i = 20; i > 0; i--){
    76d8:	d9 f7       	brne	.-10     	; 0x76d0 <usbPoll+0x258>
        uchar usbLineStatus = USBIN & USBMASK;
        if(usbLineStatus != 0)  /* SE0 has ended */
            goto isNotReset;
    }
    /* RESET condition, called multiple times during reset */
    usbNewDeviceAddr = 0;
    76da:	10 92 47 01 	sts	0x0147, r1	; 0x800147 <usbNewDeviceAddr>
    usbDeviceAddr = 0;
    76de:	10 92 40 01 	sts	0x0140, r1	; 0x800140 <usbDeviceAddr>
    usbResetStall();
    DBG1(0xff, 0, 0);
isNotReset:
    usbHandleResetHook(i);
}
    76e2:	df 91       	pop	r29
    76e4:	cf 91       	pop	r28
    76e6:	08 95       	ret

000076e8 <usbInit>:
/* ------------------------------------------------------------------------- */

USB_PUBLIC void usbInit(void)
{
#if USB_INTR_CFG_SET != 0
    USB_INTR_CFG |= USB_INTR_CFG_SET;
    76e8:	e9 e6       	ldi	r30, 0x69	; 105
    76ea:	f0 e0       	ldi	r31, 0x00	; 0
    76ec:	80 81       	ld	r24, Z
    76ee:	82 60       	ori	r24, 0x02	; 2
    76f0:	80 83       	st	Z, r24
#endif
#if USB_INTR_CFG_CLR != 0
    USB_INTR_CFG &= ~(USB_INTR_CFG_CLR);
#endif
    USB_INTR_ENABLE |= (1 << USB_INTR_ENABLE_BIT);
    76f2:	e8 9a       	sbi	0x1d, 0	; 29
    76f4:	08 95       	ret

000076f6 <eeprom_read_byte>:
    76f6:	f9 99       	sbic	0x1f, 1	; 31
    76f8:	fe cf       	rjmp	.-4      	; 0x76f6 <eeprom_read_byte>
    76fa:	92 bd       	out	0x22, r25	; 34
    76fc:	81 bd       	out	0x21, r24	; 33
    76fe:	f8 9a       	sbi	0x1f, 0	; 31
    7700:	99 27       	eor	r25, r25
    7702:	80 b5       	in	r24, 0x20	; 32
    7704:	08 95       	ret

00007706 <eeprom_write_byte>:
    7706:	26 2f       	mov	r18, r22

00007708 <eeprom_write_r18>:
    7708:	f9 99       	sbic	0x1f, 1	; 31
    770a:	fe cf       	rjmp	.-4      	; 0x7708 <eeprom_write_r18>
    770c:	1f ba       	out	0x1f, r1	; 31
    770e:	92 bd       	out	0x22, r25	; 34
    7710:	81 bd       	out	0x21, r24	; 33
    7712:	20 bd       	out	0x20, r18	; 32
    7714:	0f b6       	in	r0, 0x3f	; 63
    7716:	f8 94       	cli
    7718:	fa 9a       	sbi	0x1f, 2	; 31
    771a:	f9 9a       	sbi	0x1f, 1	; 31
    771c:	0f be       	out	0x3f, r0	; 63
    771e:	01 96       	adiw	r24, 0x01	; 1
    7720:	08 95       	ret

00007722 <_exit>:
    7722:	f8 94       	cli

00007724 <__stop_program>:
    7724:	ff cf       	rjmp	.-2      	; 0x7724 <__stop_program>
